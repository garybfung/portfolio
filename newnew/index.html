<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
    </head>

    <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
          <div class="staticrypt-form">
              <div class="staticrypt-instructions">
                  <p class="staticrypt-title">Site is protected</p>
                  <p></p>
              </div>

              <hr class="staticrypt-hr">

              <form id="staticrypt-form" action="#" method="post">
                  <input id="staticrypt-password"
                        class="staticrypt-password"
                         type="password"
                         name="password"
                         placeholder="Enter password"
                         autofocus/>

                  <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                      <input id="staticrypt-remember"
                             type="checkbox"
                             name="remember"
                             checked/>
                      Remember me
                  </label>

                  <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
              </form>
          </div>

      </div>
    </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"01004d1f4d10592cc0ff80303fdf8e100be0f35395934fdc6479bddf43fa3e046fb53267eeb266bb6b371a2a1b09113fa675d3ff57d6b696d58837701a435c2bd6be411409ce506299e7478ee4706aef756113a34e003ae5d84667ec014ed041c40619fe9490dce5fa6dd504fa9497b30f1dd4024603a6c7c9d36e3f43d8e8440d2288dd2235cfa37f02b50856197d55f0d78a079d9fc37e23a36d269d26ab82b04ab6edac75dacc13d08ce987b3facdd4bc571129f7318726f90b976333e96a8833d2d085994f5b3dc7d4b5586fde8b9008f68ea56c01e0c759c55a41f7c110055dc8d931c2653d4834f65214412be70bd5a0bef2ffc65e35280f5f9df27b51b4e9d1ace93ad8a41d28a918756405680a3b805da1b78d80ef44601ea84065f7ef4e2d11f7b8df0f5a38a30e37932c27ba1af2f9d0c9ca552c24db4896a43c2d2101506690ed272df411e9a74b58f2c0cc70d488f14aa18f4f249eff53241da20c432ac102f104d041c1bfe199e883ade76e301c64f269bd3564167a2903c2012f4e1b7e0472bd178fa0918f6f601e1a600fe8ee696caab5024ecc3dd31d206f07f2676f66e4716ff709bf60006c50c5a9d8ab47aa20791ec529d612bb168687823ab3e04e819f7e9f48c00cb9650657097e615910681b0f2bfaaf670313d3bf515d412ff80b588be014659ffc3fa6c87cd8ae1523457793aa06be82fa8fc2a4d0afd52eff6b01436f1d04532d046c300f3df2a053813ff09c76a32941321874561e54ae1db1e3d605f961f47e80685549789934cfc7bb0148b5d641dbd4d4069ac447bca64ca25daa82846d3566497a9ae20ce58062c2ede521003df03309758260aaa0ad25e4c3906e5cd86403b24d939ca96ab37c3528c975c00b57171a88c748e4f044c2e307c767234816a528227e054ec12debd46bdf580b3c2434ed3367e3deba9d1fd638edfa3fd8b5455c4e79eb0f31bf111546478ec560091b748e0d19ae6a2de20cd6bb9be94a74250077aca519987e2a233b757161a3926384eb8e10d4a30e94bde5f355210222b35e34f1045df5c912c5e342baa4e7b2cfa3d4592956a371750f85853835b69cb3a38ad7965368250d1cbc65249538117bece46367683ab14cbb7fc182f63276fae2af3ce3c6e2746410b46a4b4350259ae17f65701d0147d95548b63c2e812a2963a9e60a7a835ef30962eba3032658813ec75c8159ffa843d6ae324144890b62d634d040f739d408dc74cd2493cff51fc1ef4b0a589c273a1a69c2f3b1a0878be552a78b49db775fe9c1a76b7454b3cf78f790612e95fde2b973d4b16def95ce24e01435560f7053737d03f722d5992897c9d28afb29218edad2c884cd4fb11acb1b22f2ac7ffcbeb2373512140456e0eab9545530280c48487be7815e7b64cad8d2f1dfa52a3f267d3b4fb20294086a00bf5b9092a9bba5ff18ec052ce209af7b8cc6e99b8afa952e22bad86fa83033992c0b8f1a069188e3fcbf7f0c8232b62f28d2ad59d5b2759845e86b4c754ee31f1db1ac4c2e2561900f91b76c3661153fdce6baa7b682fbf38ef913f7715736a1801d13fae019d0f6c4a2b69476791749d9c8881727a1535f02f4f7094745735c3eac1a874d48263bef7f77b644463ee69ec6ae5120de4b94b2059419cfe1f7d5b34e2f5ee84afa004ae8064583970857ae1121c1a131bc3e728f195341b8ef849a39e024a19ce19a223de663e32bd9bf62348f0f47ac0008be7f8eea16584f2132a6c5c34b44a458ae6a35eb148b6a943b83de5543c83faad3d101e24ef9a646749aec6f10087cd370c0adc62389b7307df94bbb71ad303a9b847631b868f63062522e5b18603120ad28abbf095f3f7129629b7c05ed6530bf5b63e3e50af7fcb0ed1281b112a0c1dfaf980490112ae8b610540ed04e5fac608ad055c28fceb0dcabf1de85007e4ef2c1c8a8d287b47b545a38619047a6a33db26e75dcc2d5fb68e9447cc486adbc1c86e17b49cade1ae464de75e2ea4b62dc3703ce88fe355e64149fc26cd35749996430f964c2dd7e1d23095bfb82207255495633afe0e08c05c38b5841eb10c08d29e6d30c02b788c026468b5d9296560050d863ae8ad34e329a1eb9a83fb780d9a38c27826a459219764fd3744fdd6217aadc145cbfc248f6a5557777426c7fadc01dda8a63c839845f0041385cb6547cb34be13d38c86e142b404eeb2d26e44c1391222d1eb50c22fbcca71decb8ffb505ffb19678bb4cce714bcc6e7484512e0f16751aee43c3c4e4f25769ac660ad9bc25e8ba0912eb94b325372718887b4ad3aa545ad0e3e468b8a5208d561f79116936b412af25d7f207dd846da1524b3bbb178d90dd5a29fbf73a3b88f1d7cc4f82eb30382a7b0effb5dc2a7af86b6621c13d0a57c6d9e25b8130508f8592a45589218516485a7732c56ceb4156ff302a64e26db8d636dbbd4093fe1fc8b781df638dd93d612a479f68d4a3c372ba0b5cfa5ea0a6b9e510ad7a854d4f9836692a6cd69a7755e20beed2fd0eb9e7ee50f82a637cf6dc0b60fb5cae9dc5522ac0c033a6eb1e40c6e181c4c5eacd122e8dc0fc181efa2e049ac1c800d37a2aa26e783c2b6f331d77ce5678d3fb39e9c23d8051cb442bf8204ba294307638ce21ac175157ea97490d8d14eda4114659aedce08a545d708cd8ee09f6e734aa0cda904e4b7e9a6d0a4788260aa0a5d3f22f0e56e3bb2cb49ed6b936cd5e79e4b7cbe937a17f7d3c127e832a306dd4f78bbce4748615e21305c9bbecf0897019898fa6f22f02be62e8704d73180232ff4ecc1e1ecd4f95df071d7ed6f142474618089c968547aafed434ac6acc384ccdd9389ffddbf5380fdceb50488d542033ec1482d8338d5f1ade91638a2a5823949163528d13d1dc6f75facd7554711c5160445213b0efacf660972666c0c5518d71810f7745d950ad39b062a743756ab58a233b0f38a1e3594c30067ee38b67a2866718829a3336ba3e327bd3126fc622aa03473e5de8f08d6b1b8d25d899db68e2969fefbf38b6b5be8218a8419cfa7dfe6830aef23b3a64b700f32472a1ddfc77b152cc9c31bed10f8885b29f86f6dd5a017ce0c8d37791431283a989c82eafb22c37e3de1726c415625bdd4ba8c39a5eaa0fd50070e9c7ff14d8e615385b7904436da2cb2b67ea43f14446336d8bda98c14ae06765e26438ca575b2539cd74e0ba4a5fb9acf497b40e686821802cbf1f8016871ad36ea0ff5c936283ba87472c9f2f4ab95010b1f0be9261d60a059d3bdb36bfc4abff7a243aa7d65eab50bd9a85535bc2ad68fc3bd763354285056cd16fca1941ecc2857b69906e5248b2641c4d4841e5b7667288f2c0c35552e0ef9d749df8ffc4ba726f0d1681f871b69bd963a17249cd27e3b7f242d104e3d13e0f0683aea4a338441b86bed720ad7cba9a5fe13cfa7aa2d03ce31adcf3a1c85791488190fa0243e014f793d7e3baa1cd205d4ed9bf1e2a80814a587a82bdd822cfd91783ca5ead9a009d4d795d90971de8250acc56e0dffb0f06ae28cf6e6a18e69affce0d7d4c3de5dfd0e4184fa9b44cc098f8069c91c54a48768101d3881f1050cac75e8fa0e2b55a9ccf4d34873b8174181ddc2244d28c161d2f6c89b8e6dc8ae1ea8ef5a4ff6aeb57f38201f66dc0ff7eb6a37b93b5004a35d3104ab13a36af2a5263e2a7beb3a48a25a62f924a11f199ae52f5c1e8d4c8941f0fe496fb5fef8089a47213a77faafc218ec99ca4915314bb0e5e26999e229309c88160a352b5455abfcb17ef5453b5a1b85ef4b9f4432c1c88846b234f94af0a3d18d17ae4c43795f2e68885b56edad2f180622559d939608ddab7b08120c08869e0cfc38c33141747ce853885cecae00f459fb920f597f6daaab194b64da639ee298f1413b5549cc820ccca1266fe0fc503065c106ea94dc66e0cbfd287380b93d3e588c4609c6f3780f37744c87e3198cce900dd76b61f565cfd10c5d941867a9687c346ee94e9094c9238ebdc425b487ebc21da7b92ab1b4923e4c734affef89ed577448962109d0ca25182263e53abaf667a9bfebd129a3b423c07ab8464e605ab87fc01041dcced997194392f61684b3fd2a93cd14474b09c1257933da42b17ce4fd075615687039323ee6491fee8744845bafaf6cc5f0bb481842f737ea7f985b3a58f070d10d1474b3ccee6d6eb94dcebebaa7340f5a85df3a07990e3c5d709cad304721ed16f90632e098bfbb3144000b1604d64ecffbc5db06d22054a868d69d93207c73be764f4871cd1b07bd46679bf0e3392b72b4b966327a3c276eff320d87f41d899b44b21335f1f12cc5931ba3ff1032dffb17df6aae8fa72260b856d6b553ae2b5cf5e95facb593b789d14574afb7a21dc4962ec80494bcbe484583d829d0d7fec2b271b13c4c1a8d225b5ab16235f22f6e6b3bd589d0986f5e852c04b885a393bfbfe9cdb38bc996ea0aa08a2c76ced096d7a65de1dfaa853ab645cf26da87519f42971e7c737c52160052500b806ace29dac2989bbb8bffc97fdf03bc39b54f86ea3dcadabc484e5fccbda4c7984524095c260155617cd581991de5d28002c98cb39b7f3efc541f838518afe70725d10ead8efff3de138bb5e8d22b480d622fb176a8aa0941b898aa4181c5eca78a6e13dd9583397f8b385fc4ea9095104845f60eb1a16a4258b986d1ed0bf3ed58a564a6f1c1000ebe88bab156b3a68fa06405c6b303a804bce2ffd5ce2b5a7e4f14eb94a1b2748e7780c5e48c48c7e04a03c7cd9cd5e7a1336301b7b3a60b9c2b05b85e983de93d08f367a396feba69bc4641906399927f3129fb9b0c7eb87a532f3b496b0a25640fe80b0e11033b8a3f7619a3303ae84fea509f36fb74470f1865487e4124620951db3cd3cd63984a134e8e8cd14de99a0410c5d9fd0ca7b2ce6618e4d95983b7f4f82360fa7b13c57a21109afab8cc1e00b91113ce388ea6f3506dbac7b8a976aa85f7838a99275f5c709dd1167e77c480490dc200f9c0bfb14e6f20e6327531eaed8089cd289b886e03e17281b2a9923acdb4bb040130e023c267fc71b9d310eceda457df637c41526adfa98bcbd52576d83c52cd8e77048862044a95131cb1ee7363ee054618992d46be43e5873d66b49c44f34459860bb996a54e3f42734a77465ee0fb79dcd0e2b90b58ba0a0a5aaa2b7d0d4cf49561c711612482ca6579ed450f11a864454d4bbb389d20822045261db33f440fac6afe18a073b712c9084905d455efdeb6fa172ae6eb76b9d921666860fa06f81228bdec2c7e05520782662d78f9530a5f9d01de154d55082d1250973502efac1eba30650c6524031d23262a5a6c693f55b55e5b7d7a47f7289951e885dce67be91b2f62c083723460cce87d647473ae6bd4e865c0025faed0f5016695b2d4f276ce479081ea879ec330635592263cfa7a004709ca17bf1c57ad1b921d6172a44a67306625d511404e857dcd296d614b9a3f4d7723bf7fc5055cee5cc50a310c9e1dc527b348eeb0e133c294fc71f0d7caab30fc7c31f77f199a035b4d0b8ef3473775a3344838dec5b72a44b4fd7263660331a96a7abfbefbe00157207caa8bed9173f91308b0b0b6dc91ccf1087f913046fddaefda282fc46ecbf5bfb175cc403af1e33b78e071d6c1186c4e9dbcf1e4722cbc60b25e58650dbab7cedf842121bca32edf793d91a6aee695df1f5e9e8e643a34cf7c9df909fc142e2109ee5a355a7cd3ac7aea476e360f9dd1bf84dada9dcaff0427c6dfb23fc7d35f3179fc776b33c494e669e742ef9110d44ce865faa0b9158e7b2f4b8477ec1cfbef0a9dc01c0df75795a7804e6758241d180f091220d47d6fbf73d0d478b1100c3fa292fcef5f95a136dd091ae6a4a3a4956cce5cb99e1193036dc5385c244ee1b2c8b7b5eba4d73b6d44e51d1f1db12a52afbf1ac68fa77ff12668439d7ee9a1ca1110b833af692ab78f1822a51b20b5dca724db66f528062e71201cc3245d4e34d93a1d4b09e6688b63adda4d7a88eddefe9d84019e976136129e021828a20a5bf4d9d95b4b5808ddbd49871b559e9e8cdc7154aeb135bb5a2e92c873c155ff44450bf5d8e5024146b360af89d5d0d69415a82779baf8396d3b81c4466705cf552cd28a1f7ad77c23f9b71cea46956651272365d684c90e372484adbf70081c7a38b30eb81fb7623d1a71246f81c5a0fdf8dc34ffa7dff4e47c6e3eb04252378991585202f6a0b6da09b74daa4cf8e8e4f2c3943a69148f65ce23caeba8d820626f82d043cbd84319f2b5815015f1cff361231ec0cf9a55d45bc3786e506fb19f3a8580064a202c56366aad3219629a3d2a55475aba41df607c5f34ee1a0d256506871715985113e945a1041ac5c9609b2cff1ddbb4b04877edfe79e1b7291e53ba4e36c506ba78b76431c6c887b8388a3b7c9c158e61c4c30e4af9e0fd7dd83acaaade66ed614a6876017662b36d5d5179849bf4181d02e5334181f383fa1ed542eafc67b5e9ee18100cffc27aceec1f0d81125c9d57ddbc0383c48c873bb91a29f6c3e707caac0e36741f317c8fa610ea2c5c0f317656da7cbc1b893270836bb45cdefb378cd18e89a3ebe56a017e6e3b302fd8a97284311d626f54c2b8a0bdf6f4617d7c918c8b62929e8e4c3c75e81873212f3b7295424c77cdc2951b0225635451bb98a89911ca067af9a9529e76c53cd1a8c078cdd88945cee526e9a958709e80a32fe37283a5d8f9e9ee591657c8271583124191d84e70870c06965a78d70223705d8e44b85d7663840464e80765423bc81dd184fdab58b0ed62cd57538d615580e4a26a5e8c26c766462d59c9822a6eb488c9ee858a5fe3d58b3afa7ef06ed405697b2cb7cc36762f89d153f7462a63007370f92820b6784b4f553b0c9573d0fde74621b402ea52d2aec8a5958b53b9f6c0db6dd8096c8d23289c70adaa37289c93065a1746c6edcc7d2cb53343bbe44d4480bc2d485543930dd94395571c29a021d2918fd6143ad9d39a4d020111bc4edfce2edddb2369184a1cc3dfa6cdd06c39ee60aa046ee3856e5ebcf999685b7cf0751edffac86a7cfdcde8305c7c5fca30b341b4f9eb23ec533a97685e2e6a4683dd5b364e7a75f31cfc2a5c47932464d87053b9cbf13f7de0914c64517f7d0c974fa97a258a47f9934c1774cfab915a932b92f03598ca4e2f0330bb2aa3c79c0c92895b8b61deb6f6e1610435922298155bc9cbf396c76fadbd783ad969cb6208929c5c7fdf34a700ed69268ce700bc9ca8d6a6da16e21d80763d29f8c42692880822cc8ee0e90a65e509be23a8e320f0126f9b92368c9f8813edcee7ac35c0acd3d0afd1aefd65a6253df3199ac332515e895cd9f78fa736e6b7d2c97f3fa4ef4e245e93cbd48ff3bed8b3cc8caa615dba1b39741e47467d24273d24a8e90f0ee8446337fc03abcd49f365c48f5ad941e8495dc2de8cb6f0430be1d35cf045f793ed4c22b4cf31d5ff6a5b0fc93ea592137adb95d073cc91f7c1dfa09e829c85701edc6fcd4616bc167f33d8624701325eb3c8c5e7f9fb523d6d1b3f978a79c1f75d711a51522869b295d6e4b72a20d12063eb9af10544b00903cf1e243efcecf04b4dd5e8b983ba27a3b8a368df082e774be5904f8ccdd8ec5ef0966f9c25b00bb7c0564a221ce6550078918ca958bbb163dfec44e7de08756738cd76f002e26e1ea29de70ae1822e1749a7e4239046190814924884a4750bdac02ad6f9deed87ea575be1a4d1035c94660e4102738b68d5f1bb8141bb32341dfec3fb1810a385ce0c71e6f2583d7ffb8ab7eb0148a3236691cb6e8085d37e4fc3e39f35d9b063bbdaaedd8a363700624b10e3bd0f259e53663582d80db32696594b551ade76833df5d84e7ca6677fca2f9eacc60109901f35740f1bfedc9ef53024349345a378dc17cbe9e3666046b582596a96735bfaef09aae76f559db038ddd4ffe6f75dc603c391f4516700a066553ea44a439f8a8b41f2651462a6a769977827d4785a13739cb766add2359ebdc761abb6212370ba04e32878bd56d1a2a16f2892e478067e5810b7d0023168ece967ea6a0e2b9ef21dea485f9f3ee0af4229e439a6efdfe4f6786a509ffd0c0c9ba410351c15f1fa97cd24dad278b01e0b49d6c6a54a51a37b33fc0781ab8c4e311824b99cd7ca1058287b79cb5efaf79ca7891ff3b4b3bde58c5c2e015dee074a616e5c363b95bf803648a0cf762cd1c16a1d68174e0eddfe08a6cdc2e9689468e1175c642e84b3a0da9af319d27cd68d2f9a8fc7b4b8934dabd4c9627fec00b5893016b4fbe0f745df669916780f5b83eb799f642ae07739a10ab3788a8f9b6db572adcd2fbc4ba6afb5ec6c23f5d8119215a4300b7d9782563ee184bf606f3083ac4dd6c5fc355317cb39dd25865ec0aeb29dc66d90260ddea25516d7cfb43bd3124ae858deb0ed8a9a41121ad3e3afec8cbae3f3748c02c344f4908c23b461303339f03933b2605e04058134a750beee1bb4cf7e99ad6d5b007329e5e85e859781099fbaf758cd4217860afa6b60c2d9c4231352ed03694fcb7825e2d642b4fe6d99113b9fc665f29e14f823d71c102b37cf626c8135a49a4f6cd97b6af6cd5aec4d588be1a4e2d852d02b55a06a519a228f9673e20984acbd54df42f2a110faa0b2a9d95383e31cd70efab4f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"55be45459b56702a1461310c0f87ce68"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
