<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />
        <link rel="icon" type="image/png" href="images/favicon.png">


        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
        </head>

        <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
          <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
          <div class="staticrypt-page">
              <div class="staticrypt-form">
                  <div class="staticrypt-instructions">
                      <p class="staticrypt-title">Site is protected</p>
                      <p></p>
                  </div>

                  <hr class="staticrypt-hr">

                  <form id="staticrypt-form" action="#" method="post">
                      <input id="staticrypt-password"
                            class="staticrypt-password"
                             type="password"
                             name="password"
                             placeholder="Enter password"
                             autofocus/>

                      <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                          <input id="staticrypt-remember"
                                 type="checkbox"
                                 name="remember"
                                 checked/>
                          Remember me
                      </label>

                      <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
                  </form>
              </div>

          </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b747af0b0d9f3e9f2a615cc58e4022122c159d37acef0d2154d74e50e63ad3503f3db2df78db7b77324c404d1a51447762bfd50be1a1929a9cfe4bc058c73f1b8fa31bd64f4819e1bbfc009d83756fd3f8c5f58076fc25365cee3ce2f1db554b37f56c49ed51dea6596a50437402fb4e6f3908c43ffb588a39ff719953c0213bc4eeb8fd1a498c64a4af1b7d6bc86a4c66eee6f7e25aca2613493118e344299a037251663086054e2833f58c65d4e952c2edfaafd9473d9ff4b7ee340837f2365f9c3eba2143d2ee6f742e23ebd9e546f0fcb76f8413cdfec0ce3138713f559810e2d462abbdcf337bbd6da520b2e5b676c0fa91630762b94b8a65f6179b7f4d71f7062fb03f3980440ab21c09a12c77c6e60fc75a85a7b3da44b949f60e53a39f7390a75ee028e7d745461e1883430969776ba4c95b6ccf8f8b6df85f9d693b2625f5c47fa919eec529e7f479935bd7c53c25307c73780d2136cf90511df718aa2ef27f592e93c8be534e715df7e5b450b850f5525d39ac31c223a36867282bb332a204fc00543f30851a96ce96a7f8b12ece285dd1eb7c868038f25bf997b5057c1165c08ff8c288799b1843018c5b8b382b55ab86730f43f72a74e2ae90f04b0175492a352be0a20a02f52eb9a1e918bb7a590bf81a9332fbe1fd7ee591085f302f346fa6609002add75d583696b2099b9f0f216cce5afef8740b85b0eb75dce1851bf973c8955f5d51c0bac3fd1da1fb0668ba48d975a5d374d2aeb5569b148e24958998b85e11159c9869086d15641c6e93aa0633a0b68a7574aaccfbc360abc8b1c689afd36de444888172d129aab29f7edec5f9d3eb7111ee039c15aa94c80fa8832d610779952c08d223509604778543934f4c52b59fc91c923b8d4b38189bef66338d2dffdac0fdf5785c451c9e4c47fec4bdb4fd0e4d5d5949fe040829666675b37958f104bb79b9c4788c495e49d1173c4eef3e431f37caa0168faa97913323ed68472144b07a43ff297ae9eb46b5066059b89140639c19ea0f42efd23f50e6056474d70aaa758e11dcc33be0b155e8447b88429273e12a2f8fb25a12e9cfde5a55fc1af1a2a3d145ff60b3538f757316525193e537ff900e88bd52016374398907b08b38b84deb3c7cc8a9620ed17bad146ce69cb2f7c8ec3446932fd8f8314e4aed878a9630e5d3584daded3b1c31c4e1d0c0f3154d0a639898b8b2128726b1dc63d084061a6af441baa598dbcd64ab25fa0d6b35fd36822ec69951578ddbf51f58d9b742b0abad0af16bc29758c8d3a19cd8c0df828b23be78079976bc4ba603440a428a5bc76a396b81dfab33d7a061444d176202b40e745641724db409ec31492d232996790388c06b67dac15c48c9a4cf2159ec893ee028d9dfa17034985a59bb98a4ca7be10e65935f9483a77a92e09333d7c609dac57d4e626adfc73e4ebfed3e01e0775f95047b6b4958071d0a8a6f3b53c0480c4cf794030fc51c7016cc29366495fa94710f0e236e7b83c5cd5a486179535fbb3ed2438ed9ba050d1f21c45027eb155ad65c2f45f0f61379421fed04bd1d63f0c22c90091d385f0d27e3efac2c0e5043c6c98f2b70702676a23faecdcf733720ee7fa25d4fa8b952105d02c6bb3f8687902287d7499d5cfc4b241f4541018ee04647e75035b555b7ab6f7e5453ed38f23f81684bbfb6cd623e182646db77384915c58ad5728ccb9f42f79026f0b28918d01b5a75738318b8a95ddc9d6846d2780be8944a8816d12ad8899e08ad30837063456a26b861f95eb3853d6e7cf39a7bd792f765dbde758f3c3b41e56b6cfc0e59876a989aec8871f396d5ff96b3c0956d8b084c78f2e2ced7aeeea34947d29bd3605f96459e3646efee0c4d63e4a0094f92badb3f63033c54c9afb3dae2f67c260ff68070b615d4632159c4e921b2701a9e1526b7c897c5bc6d658bcb9a6d54b09aecd82ee2ec8edc573437d9d497c82ad6e53a6981a8d9e671094269e7c6939a48503d7f794f3cdf3f87567fbfb8ba6f17633690d2d7b3d8ed88564f87dd5c5b1d742448e051f1a767b7a2dd5b275a2100beeb6e128fd0d16603b031af7cf4c6318d776bf894cb8fe03060687624bbf52894979fe9fb8fe13ac9b6d25e1a02ad81a1442205f043c2c9cb396eef06419113cb768d47de4ee3808b5fb19eca413c51ab3bdfd8fbf447db12136eb16d13a131102add85bd84ccec851ab6630d40ad9406b2839d9e9d85ab29f1275f7e8e2f7292a6ace8b2735ce43b0124d38fd2a82e2ee5fea6f02012de46a1ef1a90578d13cd9f1a7b6652aab3d6afdf4b61c5a3efeed18c0344f5ca421f5aa6fd3e36ba3860d4e9ce5f4b21aca1c666625d34f9130a9379572f7af9a0642f3e80d4a0b9d7a3b287606fe69f9ab8f8e34768ba1265f02c7ea5fb9752e5a47150c2d399d20bbfff9bb6ef6ba66a2b439a51e77240b8a96eb8652301e9f292cf2a921a006d8b5dd346c0cee33638e37453177e00d472874e6c1b914fc6583cd377eb1176ab700526e7f883bd3b41de1f00bf5c91bad3a2d7b6b75fc8071561c3d9d803937119ee26ee2d6b3e778d2f31a7f1191f6e39e1b94c020c419800056e9c53fd3d20041e70c9cdfdf9af7a700cc48deb6d3c76027a7a40e1d6c4fd58a464528c1442b7a9e1d6486f485ec28be914850034822b4ef80215464f8cd7e46db02926611c06fa4545549030e341c4b8bc8e515a88c1c458bdfd5d6c1d84fc813057e9eed74e1c1416dfa9c0fca321401ca85eaeb88299514279ad3190d57cb1d3187cf9c998f0995f02beb5725258bf3a0a28191fde9a8b0eba1f1492ff4100f817dbb89cbefcdc2aa43c039876c1d68155d7992e4a8b92299b10414f6e5db0ab932c8c855a5517d2345710249e92f2ae0c96a4112d8adfc8bb4dfd3908f32bc4bd7dd54311056b48662707001cbb3699ac1a5e96ad158482720be7ef0935c12010941efbbebfe8ebdcea557429d88ea174dc74d31ff5681177b04edfd5b0bd7e5bfcc4340312a75db8855e493f7e7aac1b575cd35cb46eedfc918432fd577a21d10228ffd61cd5ae9b471085d47e7ebce25bdaa07de77ed96e22eef4d5ca126059b60244e232e02b6a5d6a8aff681fd62827734cce6fcace830dc64179b70d240074e02a34a501c8a29419fab64b4075962f37e6e7593923cc479e6363347f75963a81048e08d23f05007130f331a91e2170ff60e8aa2a780feb727d0571e840085eb0ef3aacd504990b8f6e195ecd06bd72181dd4ef8b81824c86944ccba26a0a4c797aa8b80f4ab651843d6aae67cb1775cad4d4d8589b2e02b5f607356628c934026d0df4ecd0b27d5157cd546e093ed0b160a7717493cdd366061f3ea65f2516d802f05f4449da4dc807c430f7978ec9ea0baeab5197661a193a2c511e3dd17e34a00e9177abdc5225ca662bc35b59f55020d86cb056b925be149176bac65942ca67c647e251ba4d418fdd5da6aab9390d9a064ed3160c6279e3e7fc81a5be963eb1bc01a3d9af405ace69642a8982ad39d5ac195fdf8610af649989f6078a8477a1148c3723a1fba803b07b737c24b3f8449e4269027e42e589ca6e14b2a293989b7b4c1328f66adc1f36e70ae83ef304a97e656736d651011e4509e92faa1dd2e1f2345da78f0c38fc7908b252becdb56a24c33c91ca47c3f2ce6e4413b5d38ea03b623708473c4d98650a23cc2eaa27bd6439088d3f6f4dff067101af5f2900473020becfd83b360ee53a423a00a7eb16ef172f07c06becd038cedf7bf826f4a1659c519926468a18e52aaef0e63978fed9962f723014ed3eb1e1e4537b36cda593cab9c5da989cbc06171025f798deac748b41937c1aca1dee4e89789ddabfb2cf10342f087fd69ef20977013462cd2d269b921c4f35a743c814d38d07d671cd62f37a52fecf17a7c5d4c38d66aa9829c093a9abaed128f9de2b8bc758d10e1843ed6838efbc8aada64165983833dee257a25dd4322caea3dd875bbf91cdbc43305ae9467e85376658cde9790f90dfed4c9a6e96ab1263170cd022aea1df165d3abdaba00d66ad98c8bf399cd81266742b8d8d8d32869dfd26c15a97ae1f9315101f3e00946652b1ed29534a36df9699c181a1df2a5e18234a9cd65d4701037415bae803b5a0fac9869db9bc24da92f8d43c24117dece4131cf3ddab47cf0862e3ed44f450603f0c7c31295aab0ace30d85556becbbd469995caeff701297aadf1f88d223aa5be1f73231b539a1ccbdfd290024cbfb39acffb771238ea0cd90b0a6749712b856926dda594a27ddf33a59639722f22544bb0c299bc4c7e2006f202bc4a6330980e2fe3ee1f521c18648e5339403f7f25fc16b536f4a188804ba218639ea3ae15814dd772b2e50c0efc5e84beaf3525d7ec78047f9874500edc7cf15e32092c571adf84e55718231d49f25f2a66e7076fd957ad2a40e1cd557f4f7e172d4d43cb09fc281d0bd8608eb8f92f7a54b89b529cc10717685bbac42bd3ddc3d39bb1997291b20aca6d893e388cd2168225bd7ed896c4bd63255cd041fe45cb5ac39ec07a25df386962cbfc3d0bf22d924a47c24c2318c4e6351674b1d2b2ed1b26896dc567cf1428c221063a2628c44c8263af180ec020daf106fa8835e610af5634477fff199f5800b1141030a8b703b035a411268dec9d12680c9bbd68c40e14752a933c1d05ddbcf0fe5c7cd05fd9b50968f7590ac8f758a0c5633fca8baead8199a0add2f5c14b823203825700bc6596d054456e9d372b2cb882a87c091dc79f800380a61951f153f389fad2396b51f056d4fa3d45d43bea6fb66d77ec767b4bdad2b47c7aca63eeb27078532f3f608906f37f322052283b7d1527ca0295c3f67f7d4ffc7afe3aa3f02867eb2c01a9326d456198192a50a56561787eba07f9fb5cbe74195c30ec02f1b2f2b18b9ef7af2c1914f4137d59b51b2742dde8e73bc4deece4fdb613fa212b959129ccc6001996e48e600fd5687425a384edb57910d36baa1793ea57d9917d6f8171641bc98c92987a95a54cec68946405431e584c953ae2c923416853ac29316cdab9fc8832cd9fd1b10643c154b6c7c0c466f8e151c803cad71349290aaee4040f682dc61ba959b3b2d437f82cd9417c74ac0e46a6edd40720781c780e0c727aeb7a898be9afc4992eef3c4b3f773fe3510351959db6c4174bff1139373161b0745e24333cb98d43f13149e2cb61b7719ce0dbc9c8dbc948a33cc18c17ab6270fa1720de0fc078a8c240f67244f4f42fafb7cc02cf46ce26835b82349f70287cbcf1aff2f926739f877a4265c66f5d00453f37293b7dc626311ae6cd10a3052d254a92c291480952287082f271b161b49ba0acc387218529fa1e347585a3c1167cea9ac4434ccdcedf4ab8d004c12561315dbcc5cc2b02aa17a80eae844de4c5a74132aba8a36f93463ce22fabc15eb36947f7f9a8daaa74351b97dac333645f3e98fd97b5905e26e08920d3e4cab37e36bb1f890e987c93e795a1d75f3c366ec13e15a11ce75ccb5a110269ca0de30cad2f79bc1aec1d308a6ad97a1f6ba29fc61be0b8b87f3c19d9dab3e6cbe8d62a8d5410015f0800fee8c0f52e3865e711f9f6055be2689f2d1f0bf985010b1f8c1aa7db0f922361c55a9453e7f716f13b06391b73fe234ef2d0ff78b24846ebb127a53112216fed214581c56e45a346c0eca70fb56886b0d5914fe4092c6456b5bbf389bd6d1b65d995403a40c7fc04b40a235a176405661451dba0e100ed5a9e28aad38e7a634ec3873a8c130f06b43f8adef13b1f6bfd3cae8d79290f61d983c4bbdd924b9f305302092d476d33465814af33a6752f53ed17622f3e2f6b1cc7c3cc5edd662b7ff182ebe8206e672b77a0c360ae46f8703a1259d51301e98fb0a4f5ebcbc765c110eec8726a0bfc21ebb721d39a36369515d196052e7a96604164f1fd1ab2b6ba48dbc343f6b7a637b8e0766af6feb0ae349c18d5ae0941c36e77607db95dbacf725addfba0f5d5539434bf65c5493820df07e84b30e1a04682a38400f3291e51ae279dcf82012564289e80c6c7b8e84ebc4edfffba66fa9f18cf3b3101975d4d813ba8ef25f967b79ca9425bd17d298d138521e448b240deeb23400840b9fd1ba18175097baf3aac2acfabc02a6985388b87aaa66e991fb45a5cb254144496425f11c1dc05669182fd1a616e958b51ab17dbf6676ea35145b4cb8bc21a6d77e2beb52f5482d45e44511eff09365f8438c210687a65554c296611a87a2d4d1ae1229d3292f3e9afd772cee9fb228b8255f986f46b4cd46dbc2210391dbdafb839eb240efb23244d99d5b92ef087c50362298736ddd471c2160a120101a6a17ad4f449c5e68a24bc3c191853e31d010316b07b5ea4eba685379067474373094af55632a8a9da222f027a24d231a5679525605386ffe0dc1d95aa48132785dae24d1f8d588f14f88dc6a21c6b5b996dab4df674c52ccc226a0a03c174f9a0ff951feb0fd815002f8e36f839b34f1c78fd04109511b73c077b3e1980dd179d7620072cc09ec2b0cfa87c3f6c274097a84f09c456f9c2fc8ca415dd35ab1a310d2652b2760f69ddf01de12c6cdf5e03e8d17150904a985b3b081832f44a2891df21522c0b035750574cbd905dae378aa8cf97dc024ca55e51a57a4fa8eea706c20e6500b98619eb063658a39d6754b9e18af10ab52e8a4f584b1118ac0d5e64261d014f5569f714150322e980f0479ddc8aed32bb658ad13e25b98b8156d032f1543ab21667712132f8566a89dd4eff127114ad9e2def919d0cce67819a3aba3e7172f7091bff88e6df6670204e137e518d26868cee541c18290b59a129ac6d92de6f8295b8e35aad94c49243d6514dcbc91201c053a68956be801d8c43180af35a19f773bd48bcf9752be6cb9228dce1afcf00f6d2ebfed63331b5d185e1ca78e2780dad2dcdec6756b2b3f9e0dd0d26656d1226f6eece3a887c4adfe230e64ddd2ab9ed452b1c2598052239b8beab142a583fed93b62c64f6faf1cfd5badd5b60d29d8f6932b9dcb63f7d447fa785ffd09cbec34dd3853d2fc8b79e424af16af03cc059c2e32bfc3d647bee000529c0bc995b2a4236d14ef0b184b1cd2998e78a3f9db5e68fe96ce23c4262fe8e10ec760c750f3a8df223913722b9a0856d15e149d5b69fe90d2d6c6118fcf719bb89988c1648a1fe0574551e626462b298ef3476d8b2a611159e31455295e5f9c851f9bb6830e29c49c01d32e77c3c493932427ececec48330c7eefa87292db6b7d8ea3cde3112b856be74975ac529700052c425f26ec9c90aab6081062aca05c859a4a6c29556eb5736a3e116ace7505d0ab21eaec6ac19aa1275972539b8f99078d9c5c81a49b3b09fee6fd465ef341da246763e806467491113c386d816720d3c18c39e646e54e5efd43e45871b6b74cdab522503de14d0a5da60aa9d4a8798196fe6c13a77d1ca7ec6bd95cf7ed3367ad2dc53da0c2e53f266858cdb18f1e513b30714ad0dca36e7c87456e1ca5565596ce60f97f62201d03475c66ba9fca26f19ef277aa69fd6a1395278210fa88790e098149f8c78ebb05ebe368bdcdc8d5cc301bd6a4ebe7ef4f84137f1348667568073514a892134a3c2bd98a6c8eac872e782ab991389a2b13fd0525ea75b10c38592acda97be0e29dd32748d64666abaff3054915f1fc1e3ac21a433c7fd0ab5e206d9405895a542ecd166c4b7570e05eccce09f7285d2b682479ed155c9fbad2dc99ededdfee032a264b54c93f329194a63112db582e9ec9103e4d55d173c3b51fa37914d43a4e20146501017932bc5fd5a204c5e065f4ae46219185db2fa7d908d5643b786293d243b7f85e27b6b2ef2cab7f13d69e91d26a895bd382c23bf9817c82a6e83076b62d2e1ac65e4ef27deb8db8df5a8f555da93f884c9126adac0ab6a9438251ce91b71d8da7f17841b0ebe8597489dea39e95a2b7cf49158a8b2da1dc75f4cef5f63da5a29f19f486340a39afe0ffdffc7272c24702925861e98200831949ce33930a7c16490d1b5b53b762c008128ee41bc4eed24e0350ff7c19c98b885c9a1ac7d24f9879cba971decce0ce42719459f2e9ffca3e32250b4d7506d4f3bb36892c7c4cad55006254f760f52a5e653c58693c2eb23b8807677af73c25ecc0d7ca54c0f11418b53aadf04220e5006e3a5de72e4395250e54419629f95d56053e1e4d69da2b08d97c99647c24b1a96653a95f2f88b7f5389dbd235df0ea87fe4c1f68c621fc02aae578a23254b1a765dfa153968c4d330fefaf7875f67949e8cda06176c80d9ad5fa139baad44305411415a4a7a65dbfcc2da2ae56173dd524c35239663bcbd1f06c026f957c65d7acae20aaee6d0f2f0f70383a367bbeb058cdb8d70192c189cdb4f11b8d99fd5feec25fc45f9221544af55df5db23096220add0ddd4546165bed8a8889edbe0ce5c4328b71fbd44c82be7c5e348feaec8609c5b0b16b626736bfb4000c2af53190e3e2881e663fe8372d95f85e517f32e9418c85e32a4f4e771c1bf1feca8cfbd2723c510cd13fbda315799e5917afe9b595c8665f2bbbf3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e4c16af9a7bbb1b9864152bbb0e1ef0d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
