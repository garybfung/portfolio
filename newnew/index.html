<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
    </head>

    <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
          <div class="staticrypt-form">
              <div class="staticrypt-instructions">
                  <p class="staticrypt-title">Site is protected</p>
                  <p></p>
              </div>

              <hr class="staticrypt-hr">

              <form id="staticrypt-form" action="#" method="post">
                  <input id="staticrypt-password"
                        class="staticrypt-password"
                         type="password"
                         name="password"
                         placeholder="Enter password"
                         autofocus/>

                  <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                      <input id="staticrypt-remember"
                             type="checkbox"
                             name="remember"
                             checked/>
                      Remember me
                  </label>

                  <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
              </form>
          </div>

      </div>
    </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"388828085df7991f7549a212792c10960af966a99bcccd6092d90a88188f4e4eeb8daee0d803bcb970d8ab478e544e8681f7a919796f480fb4c326c9e3cd72c7e2dfffbab1a31a726186c22d6baab22fd16869f322cb41adf391486715e431740404cfc84b324058215155478def19a1a7c98bfaeb755baa44b3f7631883a7f1790266985de0d228f6068bb9ba4032bbfcb2ec4e58e4207d5c51480749d082333065705ee81624f268e4fbd7480a7c146fe1dc8538aa79778b281296ae481a55ee9981bdc264cda9963cd36efd15006817c0a8bb7c978dd0bb46a9f481624a1bcee7b34b7b04357b16cb4a1a20c1df6f8d60e3c9d760aa644abdd073ce7200b1a36e28db1378acf8f630809827ec71c127671feac0e1e7520a740997c98ac9781be863cec857638663111540d21f56ce6a7f69597463e8bc747fc5df8cbe2e2b46b88503533979f26cb809ce5313512aae162112771fba1a2bd86c32edeea9dfcf66a9c2a0a216e117eb78653edb06a27557fe16914e7d0d931c260bab310790e31c05088a654ac0f45f054372afd25edc22846010071a35ebb0e4281156fe27be1a45f6515b884ece7c19441ca339de4d3e7e32320aa403881e81d98e511e014aaa918e6a0eaafe10d791d49d444ef0701693a1af45c35a37a57854e01c29100dd1c8fffbd561167670a69e9b41dcbbb320c54074f25ad592a78cdca4a002be671adabb323cca9e05c11d2c8c0b63a9a0022be0572008c08579694fe3ea00748407f0611b1e1601321bddfee64461e1dcb74f46260b41c527ac2e28d4d14dde6f5e4ab1289e0c00c518ddc2a33c4be73396cd2a5e142e917d3024e01e46519a9d6a14901b71c07e73868bc1886fc01d70b6c7bd92b4b379d1d30b6fbeb0d6cd5d642997de94eaced90c4b126a56e7cee736ffe2d67a7c2687cee0c82b6e3010943b111351a97283e2b28a8699e3a92488dec9da2c9d37db81f89801f7d2d69d7255248c857cec82c5fb1b6d4e478f761804f537f265b19c361a75b50ddce1b80ba6db4915a93f50cf6c0c679f2bb82963fac89ca9c5af2e8134a80e0b07bd7521bf661893360c450746d9c9d44703a938b2e68cd0bd16c70d6501d54e15f1b738452d2e8de0a0405fbf81234e16c1e56aece851ea0cc3a6089c3f6e667ce0a4666a97ad8c35d206738aa0d5bfa5e6bf3d083332c714b2ad0fbccc5bcf21bed0df6474b2c7fd864cd9940913c151f33ddc8a803557ee81af7400deb4a5d6d88327a1ce115827fe09a06f2c72800453e536b91da5efaf138bf557760cd741db602d4eabe90ce4632aa4ad32ecb1f15c228c33f92587b531e615c58db3d97d3bd5407f5bf2f57b28659914fc3c74db1cf029d101bd3464c6d98a6763f6eda2689b6b1c49506949b3d2f4925dd3b23b3924aff2a5c3490530646fc69b36eb8f74c32e0dfd6469f6246576ee5fb0b2e38de585d4ab770c02fc7a4d501df85c047e2732c1e2b2158132922a96c99f3d1c33f4bcb3cc990f67c0d0afc97fa120f5f83c6f60784423d1eb19201bfe64f72b663ee27601f82e5c5639d6bb38455ceb0380ff1325d2f5e486642f097ffa140c107e82fd94edea1ef06d953c275a463971e1024ef12321ff0831f7e3f082f240a0ee4e6a0348f3260d6364ef1ba70c65074afa94b965bec956135d9d8d40fc7c746137a8d5421cf10d8d30bf0d7ecb81813fec0fc4b08ac7cd19c09da71289804577dfabfba5495b0bb73b365a779c700efd362acefffdbc4ddf2a7f5bda0a538ab4f4a724cd5bddb907721973ee322cd2f3c5d9fd90d5c9b7251558e02201d3940729dc1fa7345cff267fe32184ae7f63dd2eb6ed489686d1e85a4a3d48cc10452f28508690ca20d0157b20a40c3941815d21c5b5880cdcc6a466708b1c080f657a9a28d7f5ecabafbb9868782be3aedd04259693d94dce67f3ea1095f41c8ccaf3fb403bfcdbfbcc46dabb990cb49cd22eab1fe8126dda8815137c62a274dc24032892e7b2fbfb6e8131bc6f92aba4ef50182538c5adbb9196446ee87276b13120b38aefc9b4448fad4cb531a4c02558b1d974509fe39fac1aea8dcc9d1dd1ff394e3a5c007bad88f109c7156dd26301b0c16f80e727b4a2b162888e3a8a431963e2a98c4df9f0268ba8319c859c09d96414ea7ff8c099c2ecfe17a1f29d0321ead4ebff60fc48fe01c27b23246a491b03fcc9e0268df94561ae151bd4e1e9a0a47284019b517e7dd9534f0e63b9c3f855ee1e5f72920b26cb86095c372124d1681b244b1eef34ff85c167eff2a164e1844179b56ebde567bbd0c306acd4e3f04d2cab4cf18aaccbaf9056dbe6efa0cb0a605929c3602ba62562234aa098bf368891bd88453ddbef7971b769ad5d87f0ea1481029d8806b421c8cc4682b1b7c5f58992700accd06d483c367af7200899b9e8730c7d4f032d7155b5177edf7db37d0f2185b4971625acba5367e6aed127d5dd3a0a8f84e8c433fed009ac82a4b80f2c6cb71de155b07651138580f611eaf7b4a7fd725cc68341ca937dc8559e7b16cb111a1f8224bb291ec8f92718bb8b1565d379520747f4b3ef573e48b2c5ea4f5afeb11330e4b01ca50a3a51fcf714ac0de6b23df95eed2463594d4aa1661d55bb3f5e2334ddb3e5450d582dbd88b9dd0cc1ee6c4e253aeae944b2cc13b67b1598eac7c1d380e1fcee5ecf1f0f75b41f2206e285215ff0128136d0e4198e7ebe74865f763d0fa47af18186d06d6ff4e16f9b80efca2f70c1503f4fb25560238e572a193e84b16742be9312b3214d6c3a3c66248d76fa3b73d14f6de04cadcf2160632672ac1711258b2c00b369fd0398dbfa60c3a882d0588778e2a60769b471bc1eccba13f0d83917f5fcf7b2a3acc04ab6b1b601c466e2d11c7a02917b8562f59da37b4cc84f00e712a306fce13c40eabc1f2dfc7e05ce3f52fb0bdaea9143aab5e43af515627ad07b6b1d4e9bb3fece162c976a510dd07925032d72a169e9a24a4044ce00f5214e54246765935890ae3a3784677443fa57867a7d2a2b0ab8515b626d1aedd5b2a647afc60ca350cbea1f6696af72dbe547a6502305983d7cfda19e3875af9707119d3db8592c4b19d6b6acff7bb1d88260013c52787b2ea9075504e5d1f4e545600857d831a4093776b4bcee79351d621c738cd3cb385b97f4c219e7a844b43a110914075e9bf0e0f7db22549659cc00eae442f38d5fb603db46efeffd45e163008972752ed889193f3d713e681e8d2b9f97fb10de476e558ab791edc9cf680eff2833d8267e1efb64c85bd88478a9ea7d86044270b6eb994145a25901ac1eb3bc2e0e51b2eea53ca76afbb932e6072960e044bc0c1255ce6f939756aea833a0120f1cd522e002446ad1f5168a3fe9b9a0d39caa15e997270594f1cb5607d61cd34956b1e1d62f849faf02e75d9a09621ce2e3c91f1006f0a22046a04416ec31455d81edd7d211b46d5d2b787e483909e55468df95dca27d9fa00f28fd1e6fe904b795d5ac248d9d3d6f214211c9ee2940f567059b724a0fcf3efc040a9704fc9b16a9992c9ab3da60780c470bbf54767555999d0796b4a5014bcceb7a8f47d6387231d16f3d5bb48388b37cab10f6e6babe606ff1cf8f0d8ff99aa410c9c5beacd263f30b6d594499569ec2c5fcf8bb74dde77ba48efeb6b9f8adfd4db1f1c8457c1758503b42d505b1ca7b1b015c56d1e52abfb0220dbfea19b5243c8f72373c630761ba634e633c0c0db67d370172356f25ca9a67163340414e9d789240404b8307d2bf3c7ed3762349f03751274ab35b8cd19f95ff96a5c55be79fc51bc0a588d21c9d67f78cc0a4d7a40235543b95efe1bf2d0f3e1de9241eeef2f274a73dbb380c445d596211dfbf52d7ec66ff7baa491e1ed9f4d429d8e543b489cf2cc4b72529b7f8639f71e017d6a3eb3c79adac12b3e3842cde0d3112a5e2ff847b319a904d586654c1099186d5b73d96ef97ad7147d2414aa619a9a51be5298f9cf4253fee873a988a62619c0f910fb873b72dedd54f5037fc328176f7eb12a563e93b3330233e119c67b5a8298a41afdced6a315f73816d367ca1eb97e09e0fab8d5f9f7437d57591b6f007e50b113ae1d4d697ea529854d54fba601f58c79deba4220b762b70405b707405cf6e50d9c76fa3e2091f048beda5b1896cd930dc18d261a66c695f62268a1012ea68dab183e78fb23fb0a7cd07f27f62732d9b45b53e4f2304f2565d4e42b021bd16caaf4f8c47e679baf03362d9365639a830d86c43823faddb1989a6f28278d3b439c807e39d45e33d8f3bd3f1a9e4295352cf0cabdcce942138088880943026007468fa0adc2914645a2b2d4cc7a10b70a20ff11a18c90b1a872c47f0fdf481ec3f49e97859c10adb38a04cb4e47425ed9d37becde451bf58157fad141eee659881aa2ba227690a9e98d3e5dd0e1c393fc742f198dcd6ccae1ae936ab796ac82a4c471ba156fc409fab184f159349c4dccd0bde7c257b00e0d54ffe871e688667f3e79ced94fa0dc7a359ec445527ba8910cf49fcf60c29dd31cb93ff488e26ad71de15d1df32ce612ea79aa0631ea07fb47e404aff3f17643c49ff6c714bd60dfdfb0b3c8d62087f021a9310fba4ffdc895e8d6f6cc0fe83ef27ab4c3a39cb914fac116e75e165ccb6d045100826ef51d5b1b1ca63cc52149a050155604af8aaf74c17b44af065c6273f68c312bd99c40cdd232cfb2dcc63d82c29dfde679bcb8d4633dc758d6806ffa4d6c9a6e6bb08fe73bc9f72cc82aa71a0cd00b0bd4d50d492cc12eacb979c5afdc603baf7f93006ed663ea395383976e964f44c9203264d8a2b729a7cd240ca26a9b044ded296afcb305173a5395458a9a10187fc795c92e893eba8b9add5297f23e5f472578838be02cb2914808cc3a14b00b60172e0aecbe0604acdff199f7c597927ada4f22452ada815e4a4f33778372c80f4f2b41fd0625c75e981cfe0d66d3aabd77f839b340a84ffe87e51eb8aace0bb87b4f2c0a5c8b6fb59ba98c7563bfb3ab38bc12843de8eb786c029a96cca9a8fe89df27fb7ffc232e7922c8912d63773cc29c3b75a9cc5d0ddd104877776f08cb6df7ec92213d574dfb46404d2438fa04bf644e38d14091aa03f4434e3dcb58e4154774bd6729534c4e785b37e56c214457adb8401784b1f6fc1e01ab20b897799041e6dea6bb09f5dbc15a62a77f3eaa03423bc18898b04cda712321639df969de433c8dafe51918101b1df8da56dea84ac43bf5a5e758f594a9ceb85ab7a17663820d9779c8c14a7a080c86089fb24edd119f02767e8ba0aedbae2775b08e4d03ce6cea3f36e6770a4dc377c9c2df84eb2d92e8c087f1d8d30273a221094a97f011f37fff619c3943ff6323b32928b8acd5d41adc45088efd0743672f70ee621c3c8f2af763211cddb60dac10cbc8bd9b909e18eff8af972728dc41920b8e35680cb7fea6f65b70b7d427df934bf33dbfea3d0d4009842391e97309f644d2646c4884a767f602e9d8407e568e7619f63673b3b0e79e81fb324610993aa3301482707a2f25af2c1ffc30399cb19609f52ed787d14bbe673964db9c0e4e12baa5370d2046a917e123bea17a566e712fabcbfe49ddac6091cbc4f910c59fc9fa36ab8fae27ca65d65b50549d3ffd09a929b31a8453c9d5d0f7f08eabb17ef859e41b745dbd021b163a8e8f37cdd6c9fb652aad32c6ed515691d8c7ec1a893cef653d6c855eed57012c66eba4db0b795019eb0a9caec5b7c0d47dd122da9516f28e865ce3d75a5b57ee4f17e87255311ad8f34b749e937e5fefe5c70b36d5e6850dd05975de19840ad972629665c37a401ba88a60cd339fb5f0f6f18a069189ab36c64dae7e5710892490d239e2d6e599af7ba3bd64806959d23b56ad3884879255d507638942f9f6a091d3909942257e53940ee1db7d96fd05aa119eb82e40c2f17fc9eeda51a189032cd32694c1b6edc34b07eab2ea74dca86a8b604e04311bee2638352d95004a20c7fa56f12d678e328921d9679db91b14f8cf810a88e2d1724f196ca27776a29c7d439de9bdb83e4940b62168aed10a0a2df768cd206f75aab564b61ae949ef7cf574f59ef39757005d70e98528598370bfef5c472d512ffc9f8d174dde3ad5f27fe63ecefb90778abdd7f452e5e6d215de6bdc77d626fda21065327ddc414bfe5d6d8ae7808a960a94baa8f7e2b954cd56c12e27efd28cfd0b79fb2eb51db68b2cac42a41d534769b53504d26222422231c78dfe234214d4c15694b9199c562d10e3b0ac036a925f2fd37c50458fefbda08e1556adc459871ce6d3a30bbcb64e311782d5568e854ee63fe62b171299712fca2a80e7666e4ae350e697d212342741d94ef7cc456dc18616b6014f188d475c79e167b88ad21c5baf4d6c0fb71b82df00f72aa5a8611c1c1e174dc684d0e5abae40c12eed14230ad669eab8804b38dd2164a7e9653b42f3d3979c04c0e47f557a2c0b0b92057c7b41d40557e80cb083944780194dca2b93454ecad36217184e439c922a0ca09de492f6ef6966669f67b6f72afd5ab3fe202163b70409eeb8096fa43cf27dd639e0007f68c263446ea28d194c2899c72639e4b18230452e8d2a3ba27829752eacc760c7924d4001dee92744a66a0268eb0465ba349b42067ac10182afc1f0fe71ec869ffcbd58ed2e1514935379a36426e2dece93baf137252724b7605ec6f74a4edf51d8fc4d61ce8d1b0fc42d119d637b32633470d742a48eca513928102e00bc0a5548d7a03241d42c2b8b82cc24c5153f1849e0fb1cedfbd3435e8404bea5b19c0aa42a74854fa9ccc558e5f8857a0e957710e31a9d74d8f8b11852f04a163bd9a769198ca18597c9c5825bce6619d72d6feddaf72809430e8ac8f6f159128741a58135293c2204050cb0bf67aa2daf1ddf0b6f22bae3b59c87e29e77b81a7bf01bce81cd88be99f4777f081cb4810fa021f80f2be725772168ffd9f522aa10982e14df1ceda2cb35575ede3f4827c0403b12e3db60efe69ccd9fe8dc48aa175efdd6c58193adaf353631ed9b932bb254b2b08f7aa177316bb0eea5f4c8099aa2c2d8ba41a8396ffd90e59d47ac0b196f7d9a533d5c0020cb798e0ac3c2370b6432956b82551fb7ba72859c21f5435ad6dd3efd61b71b0d5272dde2d42d058d4621900aec322b1766e5695e086fb3505a7eed191ecf427c834777c1dc0fc637012913b78f38ac1b638373f0b5c9850ad50f9d740070a03129164f4cc32aa015771672d376a0ef5cbc0118a7d7eb3bf4273cc24a9425a2a23f1bafc383555fd4a38cd3488f4df94451ceb9cd42e1ad46e3bae652fe66717bac9155347eed3c940bf8789754fe7d671385f59cd7c3bdbcea0379100590e68c27404bb05cde3f474152291c1845920722821e54fd75eff1dc02cd5accc2d61572e09e13fb91e826ceb9225e4a5a915820ddbf612a490f4ac84eebe38905c13fae4c5e9fe82f6612eb5378f761e92ce2e32eded0f4ffd5e6fdd39ae52ba06670f6533906d2904c154825c1c43ea8966fbf049e2935555e27172cdd302095745ecc5a964a919002a8f8694f14191fc8df8e328c61acfc7463df03285e5e6758d871581da5cca425d5656bf373ea4b3a38c094f9dd0885395ea3084dfa2b1d1ad5b5cb9766256107048b5214db84a8e37b75177a89a81084cca8c7bce9b3d1ea8c4f4634db41140a59f02fbf5e943b6151fbd1015a95265cc6715b3345cf0c455ee0a16562439b7c0003d6bc2dfab66f7589804621c87434a6f2768bb10845a012f76c019489bd3a78a0d71363c0bee6337b8ac23f86bcd7f3fbe4e15ec1a93fa4a0bf1a8a78be1c4010e4a2481e2d0da60e735f23d9ab42bdef3dbb2ba087e27736f7e049ab48e377cb07f626e47c4d3b0d98a05b6a4bdccf8987e769e1568172a2980596ae863ef47f4366ef41520d17d9da854919abe5032ab05afad2ec61fa0e608205888de1b9c39c4fd7c8deda2709517080e45b0795a6bf48333d2c97ec75e26dc425ef7293bfe57ab5a49db8c0714a214186a2dae5c3566ee233d2df4c78df8ce390e41fcb39f12c4997bdcfbc7c7d9fa8db0356dd1fb06816e5dde2bd0daf991d5486a4097b251a6fd13fbc5915fd4c1111534db7d90329805a2db46217d79d14b2d131a168eade59b2609332f5bdc9b2c855af30978123e9c92040cbc8efd3a4fda41753cc29f32e955cacd4e45b02e81d165cdbc38435c7887312902088011ec482995d83bc21a24e5727d0485db82a6c660124a138b4cc42b546af212e1ebd4a11afc9705f487bdd7534d21b0f8dfe6f2336dabfd7333308ead5fdc7b3ba4441c8655b4de1fe90de35d775633a9319fec43502305f7e199933464832a41afede502dfa70bb0108221514d731373a7690b5e5e4113d504f7ef802f3da0608b02bf093a1c9fa1d033834b575491c69aa5bdce643b047299c3427481e8fe87380e9988d88df4bf1a44f28492fa34f2f55bcccd58d86735b64d279155c1112c9b42dba90d91735dd3ed1fe82913cb6045ecea384fc887499c74c924b6a297c4700d8309d7a8ee8261bc51a51d050cc5d433098f4137079fec66745100f779f1979db6197a2196dd5f126bdacafbfa4459a7c5b97e420ff6b1b05bf0092f077e4fe1b57c2e2dbc4b2dd9420b3a0eea9429ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"55b813fcb211dcdac15cf4b57c5029fe"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
