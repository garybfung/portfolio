<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />
          <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />

        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
    </head>

    <body class="staticrypt-body">
      
      <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
      <script>
        setTimeout(function () { AOS.init(); }, 1000);
      </script>

    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
          <div class="staticrypt-form">
              <div class="staticrypt-instructions">
                  <p class="staticrypt-title">Site is protected</p>
                  <p></p>
              </div>

              <hr class="staticrypt-hr">

              <form id="staticrypt-form" action="#" method="post">
                  <input id="staticrypt-password"
                        class="staticrypt-password"
                         type="password"
                         name="password"
                         placeholder="Enter password"
                         autofocus/>

                  <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                      <input id="staticrypt-remember"
                             type="checkbox"
                             name="remember"
                             checked/>
                      Remember me
                  </label>

                  <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
              </form>
          </div>

      </div>
    </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"defd99324212745228874d1d77a5dad4226def57051837e73349a465de1d0be60d614a46beed2cf36e08d8e29de0f89268b24c30a8cd94699a64b8c1eca4978b836464ca6c069655313283627a52de9cb1ee889cf0f33383e9c3362feee2ac62bc9a7e7be18c15dc0b3941604236e138bdde357339b025daf005d86d6f3066cc913d96a9e7d99000ab23e3138650f514dbc625b222e42c97b6058343de70a3c5fdca17502079988c8079b965bbd7869a5f4db3700cd948a3e1a662309334184bcf3114f41fee8fd6d811eea7c1a70d59b9624524ade99180404d50fecd1f43760e748583e2637a1d1588afe30570985222a6a43ee156463d662440cdce0ed09f518dc331642156a3ffdf7c5f5e629ffa03e4894fd59c495d03d243250ef04cbe802297c4ae7780b182a1626023be92aee3ffd46dc4d4ca4878796c2690b7e416f5f3b12911e74455007f9b831c24204a6abfc922ca3a3ecac666b35551c2c4db678994dfceb924dce459cdfdbf459508a2c2ada188f8a39dbbdaf538ccc3a0b273a9dcb09ce5e035bac16846ab70d9b8c6383ce72cf1be075df69a913381ee19db0ac107e170625e15a02b66eb9a305e64248e3baa5d61a4bdb9cd5ab624709aebf5ee5a145f580734edf205957367fe7b184a399ec6de5467796eb2df6281b97019ae7b90df57e15e9b055e6deef9e3a23620fc89c798d0ed5bd877e168a937fa3a56866ea4acc762d19e627c8c02316dab246e5b9a5dcb60e23c0b70527ababb2a66acf112c494a875859a515a4d79dda61b1faf30d9f53017b30581daf92243e10a168be0c4eea01606b01b182e01f1703c0ee2c89dbb24446c600adac3684944da7a35a32cf0e600f2b0a8aa96b5bf9e8444fbfa00d1c67967a9f8376bd817dc275c7c82f8df856b12292a24cb803756c12984536d4c0b4c8b48479f3e61c86db0ef34a9694f5c4c4e5a58abda6a7ae7fce82940138d4806dd0beaf43e50aa5561ab0f8693657cda5f4a840c1920d3fbbf2d9b3b54ca191bb56610d9d33bed13188b33b650c3f39d3a2a821b463cb8624bea1d8815251bb57f3187fb1f76170ac265b2a7586ecf6bd4fc71757f408a19307f4fb0e47d878173efa56a95adca37c4542427d5b18fb69975d3993b28bfe2e5b692d27a750c5eb1e4cd883e25c1e2642eabcdc095e0615e74bd16d74a6ed3ceb97ca8fec9b34dd24c5af1f52e4a5d23218a1f67f4fa8c73d38573da326d65075aa77865467f3a24ff4466df9229158ea358b17420d2dee58b2ae3d1a528c8ba5cd515a56785b8b8d0faecc93751e19c4e0200cf3ca8d04a455a3418effedef0a0b21c83f9e641d6c2c5590227cf3b4717ddb7a8c4edd1c8579d25497fd94b71c9c4864f9f8de3dc31c2eae38f3459eda2daa5db7dfce11fb5a5c70ed5d89980791e66c2deb206fbe64a07c12d588c37758691433370391689dc4693bf9e44f5bcfcba416b40611d9d16a2b8e382f6429be02158789c25b27de764c57e63903cf73f308f176e9857c4cc1be79f75f0827f6824a0fd5c94fa62e4f48568db60842faef84ed14073cc344b45fc4744f3050b5ac5ea0cd392651949df1c6a1b148f40dd31a870dec7d4a9f5b385bfc5b098ab3164ffb05e86036e2c5251d4ea1e2744b2aa525adda8d14a27a40935bbd2027ce749b82b9a73d7d244fde3d93192af1e4cb85744d09351a08bfbb6aa1082e0391d8fcfc99884cf4579a9b92dc9d16f0da61a19e16075603c54b4534c933c9e8c9c2d0fb60a271a749409b8780c19252495e0b3dceda604b15fdc4e8c79e2b03016fa3fb499690a9b22aa5df3af5f607a3ef1a4724eef4ed32bd7e8fe9d3b5e9ac37a12b1577821471e9a1d2dd235f93419f61150961b7216740f398cbc1f648e60e5f8aeecb60b3a40496c2dbdf7b6590461561a4bae7eb119db546b40ea96984167b83d4b69505b81b65c2e67201ec22ec9d90595544908047db61a473547f7a99b292fc650be2ec9685f5aa591fddb602f844bc3b89dffd680bff70debf4520de806d3c122f159a9c5a7e6a8a35bb91920cadb3208c1dc864480018141c2afbf42d94c7018006393ab9bd71f379d8d504a0f684740995419400df41b0801ab5980024c31462b2574ee4376e3478adb7ef4dae9b3c91959091b9cd10884e77c5b65bb93d9c741eb4b2cf3e9e0cfd6733ff4b2d9a4aef1931d284cdbe6bc63f81ab831ec623bd7555ec6378f0440ce59290a6e86ba974277e3824177aa7c0fcd6415f535393041e5742c11d4188fac58593df1739c188ac03eeb0d5f88b032297005ae201737d18db848927ebfe06dc4954b21bf4a137481f3e81f448a22830cf269bb131f1c6bc1867ca5965d2d160328d94150733646a441fd3c39707fde3cc19ed32298a9b40a8c3c93fc45a28143cf9f3baa02f8d3c7dfd1c1fce89cdf5010b112d064d10adcac34fb8695727d9a056dbbd646d8737f88d8ad45f5d4a72daeb5d1942a2113ba6a59caa59d0a9cf48ce386eae08100c47cd706ceda30560cd9fe09649545141a2430c68dba9639d3d6b50cd43c353aaf172b4b31cb217e778b79e66b310b2203815e74dd1904a5909f467f3b5c13eb29f22927276525c86f8e30b5b7e2653332ef2a64cdb594310c1416994fd5bfbb0803869a7682e073f7e490172e55569f8330565cba57c43a8dbc497248a9faefc852153dd9e5e61d50e249c5cf43ba0656a224b5edc92c39057d695ba1942e7b638779e182e331fa7b2c88dbffcb11f3ceedb4f5141f9c061d28bbec9846e989a0f7682e8061f01d803dabc172e5be1d07bd455ab973988ca9257dbc5bbabd00b8b3665bdd779d4783cc42f2740c14921feef4e23596f60234a373e13ebf67a7a1553830b9ae231d824563a3d7355a24c593535c9d8d48e3e90968beeedd71838dc2c255277dfaa890d2a9f05a9b0e1b4029506c75772e201e9c93d272720a0a7eb1bb12791fa71f5433b195711163a61776bd592bc9d9e89e75204f56476536e341c5fd57121839d8f86ea1447a3a8f49f48efc4d013242ef15b5f8e907775ef9849736ff77b265551890e11142d0689497204f8db4c07b721048728a27db466e3167b15e1013a7ac2184467a5d15206bbb526457915ae780edd1020808fb9dcd351bb73b754a39aa27327b319f33f851052a0e77cc3ea022bdcf500ee78ae462b41801a5e1c5bad7880ef783a108b82573d550d5946fa419c68dc052080041675ce9386e7e08dc4d4bbbde4dbcbc7f546f7aa534946199bfe5d0e63099ebcafc69a1a0e63d72434323ae1e4de450f82f81ff558ce5caddd09f3ca7a0ee3aa013c2afacf4d8616d54ccb3c5e1548a4dd545b1d4912791accd494c96cf6cf1722ca35520c499d384ed41b3664f5b3c8799ce39d1af00ee6ce9cd9d99371b8e1fa348d8f346b208aee0e2980a92621a3d7d7a67b6471af8dae03b4d0a2d0d1448f0eefd4926a3260830c01f850709d527a49630c357a2e4f799c8414f0925754877f193818f61924c842afc42836e9de64670847750b232a7c2f167763b8a48e3f09f95fb04cc63c5e0d68e58a882f0255e730b2ede0e9b97339f9b0b3afadd8e8cbdec4ef61a59be2e6334e20d5996dc1d1664bca95825b743721b688fe3e39843256286608148c70740010141cc1c95ad88bc85d11ef6dbc20044dc3d5c989c0beae447685da54fd5e45aaf52df33bcfd799f05d45cb9f2e7461fde3caed5f9a95fae2627f6ccd4b76e2aba14edb4434f1e12ee75b1034cd3dd611fa4c59ee2a42efe8739ab8bd50d5b2632f1a23a2f33aba0b6fc82f96ffefbe1029faecb8d2fc90a8a4b9255a58433f92309710b7768999b18cd8d8a540a775708b59d75d0819c34c396e91c610ea0469bd13904cf083d9c041140c93dcf59ad93829822b94256c3cd621a33efe570347368e546fdd1ad610897ea8658a40625867a98382b4d1305479032a946dbdeba2756685ecdcf24c851e026fc94baed38a260c14fc3c72c93e800c21d6568bd63bf05a4448188adc13b9aedc25e30109398249925376ea69dbed97b1e6e1c57f9f8e935624be9e3d2e46d1436337160e1600d91e9906534dedfa68b78310126723478a8de32e166fcc5d9c78e04eeb8d032410d4341d05eb70ae12ecb7bb6860c1bee1b3a336852015db88c22723c6f990d87d5ca08563ec7e42ffbdd97b865c25fcd516744e6fdf589ef60d5b4efb301b08d90f25e93929a31d1b9ed9557df0784932f412a0c4411b2537245669cd0b9e915dd1cb365e78f89cbace39fa71fbd6bf9ba8011f4f278c73985110b140946b8d1b64625257ca2a9ab575170f7b1b0f61031b23ab1ff2de2ce7eec2b101c5da1db0713e05e0f3df2aab7bbca4b610aa30e7ea75aa3a89a29a4c7451a658fdd2bc37e8d1476202414743230fbdeeea0f4944a8046e2d63812abc0b75615e7da579568a79f426608e704f1f6d52a748b61d5b34fd9898d933421be7ad424d457000b0afee5d298c74f0bc876f14c6b959ced874fe397e21eb6315c2d34e7d9e9298cfe8fee7074d0c21d658cefe99404e558f54c4e02bed0d80366a5a2e6a417626e5be312eceb7078d47b035652495484960922bdcba2405db47e6e6b1bac47a093b690cfab53ae6c758c827d9753de079ca806c43b8d55733c0491c708cff28d4d51087034a8df551c7c587cdd95df99562f1738548d38854ff4d51b6d8aa7e84ec619439f019b21486edf670a31a6575f9ef93c441f651c490dce4803a6847d3ca8a7e96b54b76cc7b26d1451cecc9501bce50f4579bdefa026acad7b5febafe893668e5e33b67325329f1ddf3fefef7d1b8270e2999fc3b323bc207b586620022e78854823b9391a6f1ac60607be1650b28e736d15e0a591e5d89dea50e6d2d10576ec9d4335acf81072c2348282acf7519bc01ab9a3940a63f34a5025b3ee364b1939c56cd53cc524214fbac9b831c729d17f10098050c189380a5a3ae3feef00ed9eebeba4faf30f242b94355280cf7c34c8edf9561b25e7797024d4a1d16d522f9302a36d0014311d6962e6ce99aae6bbc5b36ccabe0083b68dfceee6809cd9adc903a9b13651ac99d06651563882641659d12e846dc1bba25373d0b691d6fedfc97270756cfbb7ff56eda77f5aaba7b7ea0018d5830f4bccf5f869798d57b1acef0f1591e3c5884748b4c1ac1059008055faa4d74a6924133310658d9300ddff146079b2d305812116c0e0d95e2699a4259e3484859664e6a34d5df4852783421f0d186077c3a5026a5e99878cfbee87f182bf85ff84e22a4b98e1b236bde54a23d5388c506da0b677772900f338c43e218fd0f63025c4b947b4eb37707d3a909bfecf3ab96c268f3554b104038196d3aeba8f1aed3477d6f7c5c39199641d017bd62fce4375653b3e0257e38305ff2d2a2ab34c3eb6d484725769dc53c74a19bf4ce76e72629ef52776d75bd888033d37ca68495c77251bf26934c4594f759237c04c5cc415cb6c52b62023c26479a31f8133d14343a6a3e264188814244e456288fd4549ed471c49b4ba4a649dd174c58816d294be79f78f26352e06037016d907b2b29f72841e5671b9eee5050c9ab524cde877ebd636f939c74123b06408a53fa0ec011126f6718f1033bdb5c733f226dcefe7316f0355296150cd0422ab4147f38236f7015f5c438076e12a06cddd9a8388b6fd7e9300cd859e4f0454cf51111ef83530d4f6e8606bfbfa8e9c585c7dd2e5b8878458dc0601792895167dddf8bd0ed942ad82795c2a8311e177aef08cc0ab19afb95810ea003a19ef3343ad3458ded44cfad65a3a78fcb063c5e1e30bc5c55eec2719c9d0c9d56429676996f55f29453e1686fc5bd9253bb6fff0f5e05ba7a82ad82afbf0f7bfaafb320155e3412af3a94d909e9378e0c23de7223d6642275b6e8c50ce971efbe52772ef73929f89302fe015aa6b817e96bd2de3ff96e152a4d96063483a3c0b9c5ae43dc3ecb2d79e7d1873d798ae6793542cfacb9f0b3e7d7987ca184329dfaeb12470a4f8f73f9f2e06b48990a891778a45a46bc246e9a184878d31ed7f2c0d3d835fc03d9de751f3cd6835734aa7f7b1322c58c6b5837cf3aa5ca1dc39971d34947e37d3cdbf0133de33f95ef744ffe6e3dfbc9a5417aa39dd7b54bb49459aa82c575e2b772ed9e28ef355b54567473ba0c939f7101a010e7893b94d7d0aba5b66427b0e18495972a8a4b34c2847c8b5507637eeb44d39e8386bae7a859327cd82f9b2b0c7fbd3de3bc6a2134fb3e2f89faa6e1dd848341eae30b35390992f6de315b401b4cea0d0817bd4aaf68472dd8792f083288203e3caf14a73f3f0a0bc74137138b0c51f551db6cb4f2c0b806d571f39d56828813ef53e82fffab666a163ac4f1c90d0899b95f080c00e131d370b3b84ad02e2e04a3127b714c2fa523df4a9facadf6a4b346f3fa251b12bad09ad282855c76acc2c220d11c47aa33084b7a48b25e9d4ec59fc4afbdc75671179155dbdca61d35cdcd6f83df8aabf6f39b35f4099e4b977d265958977576edf35509214b8dddd4154ca720fce5aaf9d5b6469489aedb5f66246c0c0088d8ca229bcfcbf3910b8a606ff60bbb56d901951b5e84f7de9321d3120b9f097c198735eb26ee4560203feceab30e4c78ceaaf58bf85ddcb0d090df8eefd9e78c9c1890a2f0d56b7be37f711e6b5aa47295755c01d7d8df858fef7fbe3a77a47d6b60c531a23f3e091f3f7ca347e7006adf3ad315488d533283da5f1a51f697f43bfa329ef1232be69cddcb516619d92314943ca553e082337ead9f3d56aae2f44a8570a2f32f0a52b4358fe909e6c4b531837553f733d4f005503c0ac067fac2945d89272eb0bcb9361d12a177198ad41f2d5af3d4c1f15aed0a57dd4858301010380ead12d15df165b0de18c8bbc54467a2f5f23be2c3daacfe2476e5953bf471e483c5d377a4443edbfb7289560bdaad69c0c86a41b633c9a668e6bbc4fd487d89a5a5fe959809522e365eeeb4b2ad0ab9abc1c38e462cd3e5e894a484386c6bf984a69390b04b3921f66df616e9b6e019ac9887e7650126a7810f93bc3a3f364103eee9fa0cecd68b3717e631e19360f7a061507b3ce272cf9d3a6db81285c4b01f2faf866b91106e341dfab64c770b1ab9c495048030c4ff761c1f727732d570ee4374ec097db1a34915f1de851e966214a8b9da313d26d0a8c6901192479b48c253c0824daf94ab5b0ecb6ac96cf9af212b3414643541b266b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"2de3c52c80e2c2c91f8aab4564c28ca9"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
