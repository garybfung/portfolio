<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
    </head>

    <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
          <div class="staticrypt-form">
              <div class="staticrypt-instructions">
                  <p class="staticrypt-title">Site is protected</p>
                  <p></p>
              </div>

              <hr class="staticrypt-hr">

              <form id="staticrypt-form" action="#" method="post">
                  <input id="staticrypt-password"
                        class="staticrypt-password"
                         type="password"
                         name="password"
                         placeholder="Enter password"
                         autofocus/>

                  <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                      <input id="staticrypt-remember"
                             type="checkbox"
                             name="remember"
                             checked/>
                      Remember me
                  </label>

                  <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
              </form>
          </div>

      </div>
    </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3db9aa7b8cf1aabae6999363672b0d2c75ad390046c57fcd73c05d35e425e7498a823e148d34d4fd017b0d8f4b9f9c4b63f26ee18c2f26cac20bbbf87aa2821f96490ab11bb2c2f8ecc3a03670298c2ff56bb99ef39c318194418ec93ba354064fce18991f12212cc3308289a5f2b1050e0e11a2f1bfd13b97557088b0362fe29afa954deb2de0200a7c6eb8083f077ff7472cfe680a0646e9f7dcaca0c0bb45818c515ecfff305953395de51f1a654224a276032b0ba40556b819937b5b07f6d217f93ee4466390e3abe60069e97e70d718635134f673b0f02ed67902a27c2123df95e14c9112e9c262119e8ec63f434e56b2d54060adb675f4c65f477ec74cfa8d46ba293d24ded9b00b0c4b7e319512abc6e3a2d0c7c0a2c012f5ec7b69221ff1c68081f05e952631f03a697df989860d237b013d75f3e6327ad96c74eddd82edcec2ea0b60f900776b01ac1bc58a6e75d7b2e94b3d3642fc50dce181146fa782ec3763d7fc8be561fab432bb84e607eee6df031ee05fc4ae35d0016ab04343e4c4218b9d7615b978a586e6f87830f73f324224d12b436e93ca905f2565e81b31a1c85f27d0b6bf4eb0e7141b78724cec8adf8662d8936fbdfdfc9a9849bd91e40970c7d5c49ac7b0534fdc14f8896da84b9b537155f8775ba7a25a438b2e6c8bfda95fa657038d91002018438811c0eeb6ab008e3d5a73d5e21b917cc789c55f59396cf13ed49a82ed6609ccbe69d44b64f1aba93baa64d9514924735e3628fb9010c46c1ce9384cfd2f2f97da37438a7fca399cc54de6852a55eadeaad337f73c352250b92b17a3faa8324024b25da42eae859ac3f25eb09e1f1ecb42ae574a87a5bb93709b38c45cabe6f864535be6f86401565a5b93e7270cc1c434162b371418d14c0937199f40fde478b4019a67766e6f2612c2aee01e9b3453617568866a127b1536ad5a4cf58df0c95c1d41b6f368056f16163c5d932f6dbf6e7bc1b60791c0bb3b80dd4174bbda348fc8906d2b54b8cab0683940704a16f5604c01d2c5ead63db07330d0ae23b05f162665f628fb3d67f297c9e333fef60d6876fd0d36c1efb5cc85898e24ea6b0b57fd13d8e2c363c29aa825720b62b47d5740e1dd3176772e9ddeb98a23fe26c845bc91bd08029c15bd2642294f61f6fbc0a7274500d14a8e405a61f5c8a0daf94f72236856ced3d7f8288b7b447c5516248b7db82b68b38bb35d46c9a1c31c204a9621acab95da030c01f7fc60bbb9d2e8660d8d6bd91761aa5cafa44a55304b673c2ec7670183d78535a0000522a2841a6f3ddc0c5608fc18b9760c800019aff4c0647938113fa056d20ba7c6534d215d6bcf615dcb24e26883820e05601e4e81c99d432021d8d43bb5eba11990ccf7ad8b3e3e87fc1c73da1ee6442d2de80dccc3f520995b7048289fedc8e54ba96182f31f573479453973076509274e1359731e5d66b199455da6a2d4323bacb3a0b91e4b780009936cff95f16012a07a37b0c16631fde58344ec480fc6a19f8aed1c61ad97f70d77b17dd7a8f8e4749b8bcd60d634274888297c6104608cfd8c18684962d7faa914fe0e6ac2e38bf33e1280866de9b81cd369cfe4e7eec063e47524d3b794667b0de9c8b33dd477077a758a0b423f20c04782e1733be3c47cf14bf45864c9949bb16867071c65df40681d6de392d7f998879cfd486f44cc929408b87c2cbc43a4cb35458bb741ccb948745ad436a16c121268efa843c289192f44d07c8c0d44240281e74fb34ab48908905a73a9b61217fb159c6b4a1add61bcae245010b9218194d7c9533babd7e0d24edd00beef445a60099c7726536c4f68a61f22e99aface0ba1c58b97cbb7b179bd99d5933498f8ff6b718ac039c3d1e41e18e4bc610be177a29ebcb3e830385dc7dd416138b22063795531837b6db89563e91281b56e22265aa6928098453aefa85d20cbcd2f4a6cb59f226c7612e55d6f9665ae490fde2cbbd40ccce5fd472aab783ec5e5bcbe7fa2dd1a43870e9b0e36f93748f4c54f000998de47971e59faa391299a21abd84da7a2f03f377162972a3c3169035a1c6d80a19f828d00313b20ca3267b7cc83d5c366f5e8ea29329c1325bdacd8eb17b39201349d9cc040bad6651a536f0fcc635cfebf8ad7cca6c668e105a4c7f3780d861225c47f54023c1aca5de1d62a1c2054862c2933e85d10602f71ed87e0ef12c7ec9332ceff17ebecd3057554fa093727576180112e1324f55e186d951801c7b5d4be654e5e8f4b3e38fe6287612652db971ded1d55ed312f7a4c336c82836bd9e8ab6bc1ddf871717ac722912ff3a3853f77c0ae3e4aa71bec9106f4afb14631ff2dc1d6808f2d037a030cf7180a727697b4b905dffcb2c6a5bc0830503e045eb655513b59b20a0d819587b6e38d2cb728262d45dfcb2700713c87ffd6b26c94e211b63b4a68c278312e4a063129c167b06f62b624668d3ca354500603483f29e7fb3db6818492334a4cc11ee3f3dea63823efd72b54dc511f9b2e6889e7374c1083e5169823f3d397b51b7edab047817d5ca32599dcf6d569dee91aae1ddd74f88170a87a91e5a41a6b89c3a9600a285a99adc74c9cef6779dac1d5d8b7df2b195554cf139d3cec43a03f24ea2c32a01d679a1f06b55520325b7601bec292037f1c384ab3496dcc3651fe123425cfbd42d2f45e63f352f7a7c913d4b9da47933f380e106ce589b024354c331500eedbd4455d554976ec6aaf2df64cbaf8c5c2fc0559f8d9a9d9bab6922e56ff91eb7448fdda64bc5be3bf634295ca10c503dca48d5f83c7ccdc1b584552518b66c7d50f616a0daa19360887c450e590ea633a2df22f5b85b5fb976475ac984611fbfcac0f3dd20a19035a134f084ff5f46c960711e4eff08e0c516b5dbae43f7c848466e20bd7d85dec8b368ba0cdb5e50504a288819b581ec0f6b6d5efe87cd8082a3f44d1439dc154052af6b5aa96d24ee4301d1f439bd3c65ccb48428bed38c2543fd9e3312e1d6a8621c0541dd3c20158c625d9234ae260947ed1da433a0c5a0ee004b90300394305482374df2b1eb5b9a531ba1892f7223bc1d616547c44386454cb4b1d374153c53ed4bbfc4044fe8fd5037135e0302dcad3b957808fc39c5cc10bd3458a0798f3054772f82bf4f69e5e5db9e8c24e233f5e65f81c47224b8d45d1dc2ea26e6edd4bf91c56aba120eff1229948094d28921a18369d9092df2adf82241b31c05bdbdaeea86d38809cef00a9d8e311cefae22b5c7b713110f9f2c40f642f1d1f64fc2b8b327224b3d5ef5ae5bc8b0540602ae0f993857a0a7dd0cc1037a787a902ab65d81464e3c0967c8e500de3e52cb7db29ad7006416c66edb85f019370893c0f7db09754863030d4c42de004d403ce452a272fe6fc3d3dc2b185b0dc5e23195b4c56ce453c66e20e0de38acd70f14223d8bc9238ab6850cbc6a3902615a3252cfc7a632d8688f14811b911ab50ec9478b00c6934027a1457f971fbacaad3de2ee81b11b6f959635938fa2a52c006d4be0bb4cda871c849f26801de46b0491eb124e19333c4285b2f793a4513980d89a24bf3958570ea46294c54779f9ceffa42f6fc1f1328099c6d20049425a347e3c0332d1c27aa8aef7cab6c027d8b052f96486febd9f076ab577b1c9ac00e65adc1738f400639e1f28a715b795a99cff92dda0c8d0c69522ca5b34a1c7cb5786d66520460a97bf023acca0dc96db1c185160288b0f56501e17b35c7117f96ec6af8645aed9263afd2ef56c90bfc249851cc7ed984028ce2dc48dbb851b0cc083be2138f5e363c0e44826e219182c5dd0ff0db7b5956a92b6e52c314a4192df7be4762c5a6354eb6f082ed77fc6bfa4b19ab50448204b0f57be8ad1e7a23cb25cfaff12fb603d694bb3bca2967e902a0ea481e53192d06a564f1650087b20b6beb3d7e7120762fada504081836eb267287010b73dafc0218e0036e075c383967c1630313809aaf2da43de7954afa92046b7992d960621ff2b2df9f9750be2d7b50547a2d2f6e28651488954be8aef3df0a3919ff300238b371eb5c4223dded50f02bfcc05ebebdd8bdbc23d7905d6c17670c64898bf49afd3c4ea811248afbe36c5789bf6f5e98b4cde98669fda45562442e801d1ca29dd621a0b8908ab2380d710127de40341167199394490e829b6e164c249e5073c4bbc3ddd6b34b69e8d581a5b08ff6d75b9f24ca76e03672562f0d8986448af9bb32988ca67315f1b658b669faa41dc9ef962b85812f4a11e8efdbc87044553f9023b04b5458620ea07cf2a923f0664ffeec7c3f7d42718b6f760f713e42a4abb9741d5b4884ae77fa4564ca0c8a13b6c88b8e7ba9813b45d589a62a11f81c7c6c35775c76f59e8698c77da906267c30894fb03c05669302a2935387e26ac5e4c5a4a58b6d9217a57f4c148a7e22d27d4d88165d6cac6098382b13ffba4750edaea926132e49ec9b69da2fe84e2299a1acbef7326455113b253df229f79aec2115e495823d0648a354a66f4e3d2ba5076e4e6c7a972ffb7f303575a22882d41440f16e3cbc75c2c9378732c1e989211ba465b336e382d9f5db24d50588121cd3b9c1f1dbd19f1f385a594b5f3f3f84145fca1c151ae37fb04c5f6c3f821b99f418ab0ac864f7db9ff71fb145e3caf3b0daa26e36f27b9126b7275271b57dd7b868a00dd7cab26bcfe4e488ce1989918b7637d36234c993d1bc94b9d0be9680664f23f5810c552095a36544485ff018c0db88ccc2281289e177653e6624eb3c143a3ba561986572f8d9c3a5b6cbef31a7a316ea9e18aa6829ef82668a9a8427b80a35caa60ed82766e48339c98f3cc021756fe4827316e6e018d2b2a7da095a791dd047cf7a47d0dff40df654a402cbe4fa1e034a0116338cded6a5383706601bb5fbc7df833d2ddc30ac73b03007c06c42c94dc2e1951bfd3927783fa393730bbca6cb3d324efab6d19ed56e1f4c0b73fb5bda7915b3feceef1feeed8ddfffff2c8fcdede106a350cc3dd9ee8174e342698158c59637873e821b327237332fd53fec65766584e01ce57fb31f840b85d1b35c09ef776422f0894df303e11fb2b7983e2356b2415fa24c91c824c9e6b8a5f71a23253e2f2291b2011d1f2bca760c450d71d81fb636e094943c85eb985002941b104d6787a0f3678a21cb6ab375eb72aa4b4a2095d93a08d1a62888ea0699ff8a5ae7e26d7235c799fbbfe70476d471867ebc75869b9b9dace341cbd7b9237a38de8daa8cf5a58671f37413597f567c4fd26b10c62036e735fd2a740d5aebe73bd3f3f25a8d3eb291c2790ced209b844de0d90f951cc3419aa198cada3e853f20a79c0dfad172e14a2dc31d2ccb84107a0a1ec71b828808c210ad806cdf8ed157607698e0ced10d7725f2c266d8c939fc658913d03a3fe87e0cc8307f5208e5550e576f09423c0db1b87ec3fdf5863cfd327d346ae5acae076d04afe0db8f926c2938c7a55c0b2ba39b890aae8df57f8f396ee653960eeb8823b1d8d9b9b99824054053595ace454753a63cb4ce53803237f3e687f55634097d0026a6ac313b1996c15db562f893a473068836b8eded809a497cf0fcb2d94b02f10fca76b32cbf5060faa8655cc6427c0ee2eecbf6c5b8dc21d9a7ccde103c762218b99b7a0bd95fda410a07885f295519f6bc7a61a98f7cb8aa9243905b1e24f3b23343a6b5169572eec893f822d6757288639a66c6d566603150f27f134692539eac148bb130afc36871d6048ddcc6b7d5e658f1e700db943e60b92e033fe419f43f2be64500f9cedf5eddc269fcd0ba0e640202517531272d08c1fddb266a321c27096f996124f8deda61e34d2ba87d57849c8f47e3a6ff3849ec2c5841399228811efc15a9f8c47037b4efcd2ad610897b367827f60e1aa1849d7064fc9acb4ce9494632a4cb06a5021fad0c596e63fed9d38fd5531ffcf82a619189edf066ea84397a0e01cbb4e44bdd4f5fc11ce066b445f6626f44bdf3eac9bda64fef5afc0c78ed50bb89c5fb797568809868deedeb518cb1ed104c36db0f65d753620342785ac80d2772d470e563b180a142d75cba36a116c65ba1cf51a1bb71d0b0478072b0dcf0349483484752fa029c7779f73e65340ee2f54de3b3d8c349b120de98f709b19cad7228bd7b1f23ac7f1d9c308cb94cde28e26545e69906ffc8c7cd28a7d500dcbdee309c2d6ecba29124101f13cd50ff3a1b639c7745fa4853f2a818a2cd16d767796bf11d53449129d60b2140acb67d07560dfb5a6e9898a1a8fdf365a7d85d7ac1f301cea144a6eb15803c14e9163da56c820f639c595118dad284337c438eb2ea62eb99fc7524efef48ece41d0918082a9bb38f854ba28647b679f645839413a68056ea88fa5cfcce632aae056dafe1a1409b406a2630c4b29d1376fbde3e7f909903fe66f00b98b9a115360e7268d8382af1b033c2c97dae60f61ce3422315dca5135219e7a6b354b7e992691e9a221197b6e91c9f3888cd3d6ec86268c289c7559ada3c8848e288c48b833ce194a42bb18397c4d781197b9ad0d170fecd91ab93172c75c599cb4ec4fe24f8b23e07c1f01bed7be71b062f93e22609afe7261d7d5ac3c02e9dcfc7ee69f14d9fbf29d33002f91dd39cc5d6db016e256f7b16083ed9afb30c36676a44374bfb95d1b493af5b6f2e0420608e92c76efddf1545e315b54ba370ede2168e3af2120b56cf68f189a30f9077a1240ea0be0571a071686a9119c9f668e08c0302427b59704d68e46d9a855e974b10da066b01a3291a70cbafd117c32673511f931ae03b06052ec4a22807e297f16546907212b2c7585c9a9cc8ed4a3610b897947c31200968f83f0fad1ac9a747b9e81ea2b876dc8d164c99a8a619a2657efeb65624621a9db4a2701923d5b193b529085344a00e6ad336bb6ec7a9cf2f92ed6fd69dcf6d756499444ba3306cfd4f44f34d6ca45c309c888f5b2ead1962783fc8c3bcb16845c7bb434e6971f33cc5c1036408d7126080fb552c8acaa6d555a99889c7bceda05bda83a49834d151cc8c16f92baaffa757631ea5655602d4bc0d172b44b6458486630dcec79414ab240da5a40b11f272b8bc827f2899f2e2c1649b5690f56627e877e54d5f5c750dfe04d8a9c0126091eb288b06141803d17dc4cd5860b52339773816786ae8a365b4914bcaca685688648d7431cd5a713750fb67be952b200015a4054daaac4451fc574e74582e6eb45b90b14ea93159d3eb9e1c7b8432a629a2a27b17534da96bb47076d1b588e37c8430841b1741da57f91856b12596f0af2e53f006dd743e37fc540055b765564227ec13f0ac0753608b4f96d4fe80f6adbe9ba195efd9dc255da37c8b8d3422031a9a32e8260f60ffa3b7476800d5021c8e5adff066036cb1e26709a4d5d55c12355b3943fe3cd527e48f56a107a444a3dbcc03f729c49d3b52c7363a27de7b915601b68f60d62e28314e9958d5e1aba987a413a3b8b9c6ac0ad07c29071904bff8c174cf5bda8ace9e43f414748ea552061d253c62ebd03fdbb2e8bdad786a87d58e18573d631d100d07745ca739573a02cb8045fdc8e54b2f79fe73bd189488948bca2c544dd767886c1f8cc8d50d6cef93b36561fa58915f2c95198281a6cf2b79faf810a85e1ddb00b1598252543eb6f2be12b58e3aa134d23f85a2cfc6c61376b80503f33ce1906f1bfe8cda650f101f9e958febf63949ec2692789dfd782ff3517bcb06bad4f5610565c411e333faab9047c7d74dfc36b208524dc5a974beb3bcdb5d3720549542de06bad38f102df0ca7485c6dae4cf19bdc8df614591fb1de69105f933ed5359ad9fad5049afe7b0d8790a8486efe7ceee6b5333b63161bb70aff841a8ad8217cc39df10e98013304b44523a6401a8a2a214f2e6844d44fa50e64d2659025929ab347c14f99db4d3d158f791512b4318c824","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"b2f9cd3d1d39e73c7c00c490ecd12a87"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
