<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
    </head>

    <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
          <div class="staticrypt-form">
              <div class="staticrypt-instructions">
                  <p class="staticrypt-title">Site is protected</p>
                  <p></p>
              </div>

              <hr class="staticrypt-hr">

              <form id="staticrypt-form" action="#" method="post">
                  <input id="staticrypt-password"
                        class="staticrypt-password"
                         type="password"
                         name="password"
                         placeholder="Enter password"
                         autofocus/>

                  <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                      <input id="staticrypt-remember"
                             type="checkbox"
                             name="remember"
                             checked/>
                      Remember me
                  </label>

                  <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
              </form>
          </div>

      </div>
    </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2587035ef84de5a65bbc9d939ddb1f21d325bdebe790908136cf4b71dcea0dfcf137c42fe2b6ac8452b9b7a5deedc3bafdc534ba745e74410db882ef1071be06e9310cc946d6efd5ea8e9e6180a9b77d0d7a80f3f3589c56a0222320c370fa54418c32192c70bcb0780e8206dc58a9025ba66f9eae47f8316bd37ef23cc4aa03729adb980247ba0881e8f478043899724858d810e6c988c503306417b24f8f57279e44194d317d516f4a8dcfe07d5fb2abfce2009f453e0b59f1d5fcb0380ea50d5b6fa3005f221af88e3a7d597c455a9eae06ba7bca61acaf14a1c347aab6fe2ada8d96243b0b5bbb304e8181356e21ef17c296eae574bb34964f29d92d2bc5dde8c11bc8a570ee81d6b718d3493b68fdd29f5093a27721dd89c53818be9c248e65cea9868c4e6675b193e6d950e313edb2d49da54437561ef6e42c12cc4284cb75ac06ed15447eec974d25d1cc1462b6100dda18e0e744ac5ce352797da5eedcfff7adcc62a601ca00618b507a316393da81caef26ad184bf11df5f102df2109a03a699b13df7ea9080bb44fb29726244ac6ce86cfaf43bc26257a22468eb0d1a0288267695735c55755a753bbbac8a018188f80c401292b3ec364e4b5ab26593ed2c9cbf3a6523fcda0c98d69ce29e97cd5b1553c64a7ccef08c0ba0fc80c46d287603fdb117c546da4f734fa67a91d864750b96221eb24ba679557ff3502953fd5ac8d8b6f1653429f4f8918de43b9078e8a70726ebe49de2c478d5a32fb76e7d3115a5ae0d5810099bb469cc30db794ed76ad42f29121af4758b0ef2540fec446832e3ca67a181332f84b2af863d3ebab1c37c0913f6999b737d181c416f12172fa47fd239be93970dde8c74f4c40b2c16cffdc97e9a16255c8dedaaec9f8d30a227fa62b086deca0e3778ff5317cc7d126d7f839947041ea77c3da7e89bd16c8a12408b8dc3c37807722011721e6db86c8defd0a892afb3c190c09d78e732113fdc211d06a44ffded2a644f6f6ddea2cedea352a866d0f41ee2e424624109d678f9a2289ea36928cb85a6c4c5aabc1b3d974fbd8dcfb2aa7d5fb3e4231678e99c5de2258384547b5a8e3ca9aa2764f78610175c0627ae9c4d12b1bff3197a22d23d69e34a09b582243ce15a203247820e47095c323e1496ef66b45dd27bcfd70bb9c306a40be52faa9818edb429025fc516855e968fb723d6ecbb4cd470c2e46733c1deb11ccfe67c84042d3eab47b057bf9ad2a30e41f05a44240bb8e475e2fb1cf6eadc327bdbe43ed23d59011b964dfbb3e429a89d200b10507faec7af551a452b0a78c1b92c171c4da878b34b7d52ad19a58bf6220d11130c2fa03f0d24e71c935d2aea48d3f84a6e3896628561a9f41863e8b748dc33f19edae71f224b6e9c53814a8043529ac7c245061ac4cb81ea9ddce101917550f9c51efb83936381e6a42f8b47fc87d771cd07bc3b509b83d6db643a2848286b7abe81bda60478460dab2f02dc6abd789b5d941d06b5e653b3ce72017708f7a34eaf86cc2df266847b1af45ff7c098f8fd8afe9cee2f16edefa16a5a7d060d858dfd8d24b85f1cf9a397461693ca4a82541a43c92bba8b7505710e1289d36a4b881578516ab0fdae4c8fece120b7358aeb4d34e91aeb4aab02e4410f28b188a4df2b71e59467d3a1f09306e6da6ec461d3351b33bb885f7e0f54aefc0568f5df0bf4c5fe894c81dc0b0dc6631e3da4925284a5e33ac43f44e978fbddce872380f55a0665a54fabdd33b3d6fbfc1f8a5bc44fc8a2066cf29c29c16e0d8a47ec0b1f8a495ab2c3485af71e5d338d0f6e41cd7912182f504b4a618c9651540874bfd6ff10a5cfb428515bf71e681e3d78eb324369554c5aa2c5b5bf2b220bfe095330b9f27c4cb3ed53cb0bca87a7a322424aa747ec3c6507c9bd25b00dd5106ce5378f2134d3467f22524621b9591a819aee6eb7f586a2112b5caa8e45d87088994f1018399092d504f6b26f1481754a0c75736714e8e59c1e751c0c08b70a0314a811aaafb3bc2e37439a272721545104b859243bf5bfbdd35b8a7dd43da875dfe5a35e61991b7fe25c9609cb0e8e87ee954d18100dd641c12c9b4705745a7c86b2fa64e6fa5c129fed3239d7b6207d72baeb62420f1cebad0c72a3fe22f9998ac275d456b562a1d6cac2a275fc9171b592c158df14994e947c63fc8608f63d88b7f7ae345d502545a5ee17b176aea0837fa4fb24485d0eefc6bf7d48af5534cdb9663f9fbbc038c60f291cbe315e52a6668bd11e30b40b03d6f8140b44c7e4466fc6ace07066046fb5c33d280d650cf877a3f5fb9e5b82886802c7a8817bf6f92ade13d4d0728d23f39d4292cbad663021c92c96a4e2035a6934f12b0f35ad57de9a42b58f02cf689dc5abed5440b0f8183672d82f95cd88de4e327cca5fe8419326488e2ddac7b2d40f4592e889b079304877f3f5915113312e7f0b34fac8777e7e466237b347fe76627f76001ea25ef6a47e2c2a65266f663622708a0eccaed0b7ba1662462007c0d9013dc308cfbb8364a840c6d51e4c4552a36df0c94d11fbf1fbc4e1d694a2e7fa8c02c688b18ec73422c446eb29c21120f0f9624498b714d6abb9b22bbe5d47bf52c41695317313c08e22b3e47b4318785a172f8bc17b2e40881732121a10698a10e8a1eb596069243669b9fd4b1a09db2527bd37408169b73d72885a41ff74b0e42f289227a61a84513183807c751818d39ab5666f5609f8f570463e5a2abf0b1cf4af1c133725707b836bd065ce9d257bdc1254e0282cc6d5eb1736bb077a69897ab37bc71859f9a66c87a332bf822c96e02d752aa7f323ee0259a7271d9ad63b8ff73a6b8e8b92903e3190645cbb348b44a612e9ab1b42fee2a624d7f4d1072ca5a68dd953282d67903d866ce6b8a0ed4f31bfc43f832f063b784096479ae47ad586c9d131acaa07bfd33d0395fc1f4addad7b12d7e6c8d4438eea353d17d39f18b5c2ed5857e7602b1d49cc6a78d3599d230a504e142b75c45c47bf33549e569875de4aa6ade0ef5ec2cdb851122dd5994b809d7bf5265e0a6277c18db3f763e78618a1d401b8c04114d8e6cde4b8b0ccb8cf959653ecb6f669798012ebecbcb513ee347ac7f713798b3bc7dea97f279f29b2882e0443c2614305a3d71a3c1db0e5f2df3cef008ff6e0c54c6c8bed48c3c158cfd80e8a324d37dba18f64099da1215672498e5eae94f1b936c94388f4c4b7dcb4036fba39786a88dcec8017e7c0606cbde82bcc9d6801a0294bc7132cf5572f081a04f8295f37079f067799ad2fa5342af86772e63cf1ae63d8d6637f304e15a98e1757142be3211148bf033f84fc8be50f853834617d94a921e3be1689d07396b43e83b4757fd114075bcc383ceee0755156d0ba660fe2ff90e3ff074abf45e330c9aca8ebb2e1113e2d6b678dff05caac7b448cbf1bdc773248c134a44109e8af4b0980c62ac973c4192217266162e378164b496d42b511a33d64422e3f2ce3dfc3d8aeb5701d7e6ef2337f6e5493997785860a966ebc2ad46aed0d14a371589b450b01034e5f5c7f5348ed880fd5a81bf31ca6888a414b0384e4dc0a0f6d1dd126fc28b0ca3e0cf21b9e6623b5c717dde65993af318af5596f2dc0ae8dd0ad108bf8e05b6bd1d1a8f6bac0145a134ed5c89a68da9fbc5b7d1cc71b29a05293b63baded2c79c4caface8688147ee035c7988bb4d30b805bca2546882aa98d4cde4ae9a98a66d67a20d2f7e1b869bb1109ffa4e9fdff327e1e5bbe5778bfb6530eb0f6ccccd96eca12e05ff1e3e736135fc61eb7bea68ae74fbf51555d2d0a8c9bade33e2faeb90f0ca5ff96d9129a324d11d4c443d9ae015e6fe879cbfa95d47fd9443d96fcd2495fbf756f6063fbf70811a464d6e6d7e5d88f2b7c51cfc5c8e2ce7fc01374fad5280e92beeb4798672f822cd68cf6e8ac1077dcd9d714de3911a6baf4da27eae1bf5ea06f6325c0f2fbca8852aadc3d087aea849703fefb162519f9d66fa633ceaf18376bf53652623a2d7ab1df31636f0ba4875d57b7c3aa79b2f8a41f708109358681616f138819fc74e03a0003b9ba4d0ed319ae54656595ef3b9b48e1064586e340b0d95bd2efcbb5500aa0502a70f5533634e5e78a769330c1ae2c072d024ccab1a029afd0575ca72b6b59f75da28c2dfcbcf278e612b921c74191c9d4dcfb58fbe938d82d257edc0f29797f2f369d644d16e0be9fe8ae64178f2c7b54699ea012391bc1870eb79e51e359c995b8d482d55589d6096999d6dc4641f57ffed8304ced8f47ac31b1628a339963622ecdcc26f35d92acb06ebe74342fd958b34fc6ea09ce84e8ea8ed2ada6afe1fafb246232f6f45da7095b44ff7bbf17e4f661a5a6bd922ac6f9c315ea64315f4a70dfa2e2a6e883298b3f894e14d1b30fedf1caa0a30d1c05a367001435b20ffc8c2d3ba8966f4c8a7d16b29aebceda7983a54bed765c170225660a53d96fc13f8027a7daa17b250cd182247e7a16ae16dd12882abc00011bd58fde6cfa81f1996f9f91f131945bd91eda23d937147ab669ec68531e35e42545f14cf0c1ff570fc63cb691d042fa98e0f962bc43ee32a1690a99a9b20eb0cb3c5136ec826e05690375be7b1718dd46aa3fd60361caf719aee9f5a62690bef3d3e9d4d21112d5be21bacfe67d1b8ae70078e8405174ef40f42427602dc2d1f6e780aab3ed278791427cb95123ffdc736d99830224eeb574a637472cc12d7e8953ac4470ba80e8307f9d7ef71f119af15a1ba49771d5ac7fb5e92118af3ec26c889ba49823ff763f88da501af64f8166099adca5e619f0ff59c3d5e2d50afefe961cfc10ffced6ac248e908ba6cda2158ab7c9057584240882e3d9558f02bfa2d477026b89e9e5f8582ea6815d863f5713b8a1a2d620a4c35ea7b37f345157f1e704dc96f162f314d715ec44cde428e1fb094e88bd4621a2f878d434bccaa27cd9f10697738fb8b3abdac0ede29a4b69700e84406bfbcbc9ca558006cf104d1d5b9862537a2386574342ee6dfb52861a60b782c73e7ac9f66f2ba2f425437a8ff38b99d30455e813d1824becc2a79ecc22d6a9bf279f8f8b1606d98df86e4f0901d8f9e1c0d45ee2bd88ed96c69d879cfe3f9d809c1384ca11296f502c2ada756ed0b4accc0718630d6aac9c556cf940462324fcef2840ba1625e249bae5509a6891501b8ec1873b66f44b2dad37a41934af46a945986d979daafb5ea05f52d9b5049554d47535615a58de007ded81413046a4cd785f40027d028e22ced7116263ef903140e6b2f64f78cefcffd98c05878250b7434a128d49e4c24688c7d6cb5203a2ccff432ffc69cfad22d1ec266a42b8fe70f4d63f78989f2ee24020a1b9be22361f600b4b016e644bd817affc8d0a003bf1bb49e37edae7d6c96c3e20a04302e3b0bb7a6350bb0a31a858411ca52726fc2c25cc80c378056612a5c67652e178bbb4adbef862fc4d0304f02c187e2b1d0f6fbde4844d7db1fc440d77c03354982d2008a2645016138cca10bf74660b0acbcc375df740d244519e92616f55eec71cbbb23f8a6953ef3b04c3063faf1311dd8a30a999abf81cc0938a6d2a74a3dc9bca5da162962120eb53f8c56fedeac42aefe5398cdfc0e05742193e613cb77943e0e96e9468d279a00201e471220ab451bd3440997f5b931cd2c54150e12017e5d7b52099ff33a148ab9ca36d1c2f75a7f84d238bbb260cc187c2b9a9296266ee01f32384edd6efb4d0495afffdfea7fef1143abf233b7c6d6620841a966a9da40faf70a6f0e9023142383d79a1bf44bfd8f0f66f1c14bb491d2e6715b2a04ca157515553dd85d54e757db7e25280071fbe02fc6c967b29c210a545e7b89bd31d5512854bc161d38b1473e0de6d85510f00206f5ffb4e7833f8a890533e41bc913722d49589f120f48dfda542131fa9304b1dc8bd35bddc6369e6b00b833e47543e9362e997d2dba04b1dbe21c21bc86f0953d7f3b38d8619b655b72390f3ca18548872d54f2ca59a84dafe6f4046af8d9a5f4379d7ee2200122a662bf289d0e9f696a0e497d9db65b7e85b23ae11a5d444e929c7c070499fe83a54a984b89d75ea3051145677d1b677575989553f1b84c5b6fc2046d5a33a18c18afee7f97ecb4b8e35dc3ce04b5fbf59859d37e296114d4c91c81b692df000bb1c9740595eae1b7491517514d8381955cb894346e39d8b0aa8c13960f0083ffedbc63be5b82756670bee0251a66b07279f9b27eaf46af45087d91426cc67ef5da69c27ee115b471d80c42fb929629f5c462ea26d821c8236b4c8dcfe3a54a73c192baa6d7367e42e8c0c1300af3516f7f1b658a662c1782dbb3435fd756dc31b8124f0c19f764b47b153f3e658a2213245718bb4ca6900c5bb242b9a6a073873efda368bcd6381fd5cd6e61b624caf1a27360d9a0d5bf3331dd150bff113dd3ccef1a3038ce4e15d863870039b52ce55abfe68e8e2db758364dbd3bdd476a0cf0f4c4928920d62eed4782248e808870ace1f5e0abc50fac562809da01775ec4c946815bca58b182e32f2223666ff614a9b1c543d6a815bacc7d49d975d14a9073232089151486841d34ed1061f64b7af3bb49dc4c662173bba016f105ed916217eb0ebab2e76a322431ca10f71566373f1c947213d10088a29d4e773e2b697588fd893d31642ae09bfb2f704f2c367e25104973e765c8798bce1dfc7ade0ef9fe5fc037b0a0952ed0d1aa4c958b4ce3fd8ce005ae5276f2fe6349f26fe1a5280808fb52cb60255a0e688b7518e5ab6bb4e5c85101968184c5128b39c27de114fe52553aa0f754ed6c798822832475466cab33797e445d46bcddabc8c207d55669fcb1af1910f202cb02e3f5677037e95890f0905b1bdfe4063816bef7aa351c837e1f1da5bd592fa5875ccc49d6e3c7efe720162ccf735666301e7086b65488ef857ab25b863ffe8c269a76118dea1ff28f96880f3707f7b8b77ca2f4d4e8d6c8b9c808ad6328619e9eb0866eaac87a4412eac3a44c0414ce7504976880f0ec73f658eb4011810bf06c01446a915e9633733bda5ea83341a53e21f94961bd7bfe07bebe5673c99a2e5cfd0738b94263296e0ecb47ede6b66c7801217131745aa2c1623facd8efc6e24e8040c7484646e5345c1e13ad2047e1e8f0bc02a5f893e7a63092332e17e6d80bb579d0c149be3dc8999604c347c6c61d30cd79bfead3bbe2b4081dc9454cf587c808125ed7ff445ab8f964900c9d6029f26d4a694ecafffb0084854a1758aeb29ad70620b7368d5ff3690bccefe8ea1e4fe9f981cc3262fc9613a2ee2f3168bccb19ca15405a3da9d261a48c8d76d58dc9657f3841662f7c22f2d2b01329281a3a08cdabd887cb5dbbb505fc950168bf40e4fec720e3a02429d2b0b8e1e9f4952ce9565fc0b233c10c052f40539a470d9c1f47e9ba2e8bf5a7930e3d75ff394ba723db49929df9867dea7b1af77898f517ff7cbf0a820594f2b3944e0413cfbe7c49bd37e69688a935fd76fb551c94712c3ec0bc14152daacd2f4373d6b6817cdc2995d0d24b931daf84644409d40f2880a69398b17ef0465b7e75c43d5f9002e210e044644692084342f33f30d2de0f857b48bb0217cd825c29acb3f69634041df51716aa13ae8da3b14924cc65e9ad9c94ea19072e72d8f51aa13fb66e582c8c52673f36edd52b8ec6c47d83880e52b08d556efe16dfe8f0439c88121ccd2d45b33fbc54c870b51aa9b031e8e86bec88d778382e2ae238cc05573744fa7cd99c4a944b3043b1d1c9b092936abd96efbd0c5eb2f7502f4f81712f9cade63adf8050e3c54d82adc717f9ac7b4569cde6bd38b9ed70f4057105d3a50baafa7d541ac6de23deb8ac0d4422ef31d93ffba603239aa67ae445a1fd0b1dfa3355fb46c55eaa9630cb8b959b6980e32dc21e7b7dbf5e0aca963fd1f6c2c523f5729c7c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"afa837e1b89b95558aaf57dc63cd4373"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
