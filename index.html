<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />
        <link rel="icon" type="image/png" href="images/favicon.png">
        <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css"/>


        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Site is protected</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr">

                    <form id="staticrypt-form" action="#" method="post">
                        <input id="staticrypt-password"
                              class="staticrypt-password"
                               type="password"
                               name="password"
                               placeholder="Enter password"
                               autofocus/>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember"
                                   type="checkbox"
                                   name="remember"
                                   checked/>
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
                    </form>
                </div>

            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Password Invalid",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"60cf0a5b5b96e636c15dcdbb7a09e70c61bee2ffe65f95283f0ff0c5f8d902d6c640656a758ae60d020bac5123174685c26db24bcd6ca9ff913bd48ef5f995d0a39fec0a0b121064cafe9a650b8a3b58c973be9fc7fcce23ad4d2b7f88a4a1802b4ee03930d91084048032938fa39e166a989eeba4ae73de4a1d41e8525b8b7639c2781cdda9767ee80b7e0efe34705bb6202ead835e95dd1d0c414c019f55fd6301757ca07f79de9332bead41c5a6b399831fe5e360435f6ae8fbbc4c2bc36da2d720583fb8a9f455c22bf7a7bd288e238a14e82144fcc3df6c029e49bb5a9ad9442439b6d7f191ff153ec059d7cbb622898a78d1127a00f3e6e6c45ba7807c378a954bc596e11949616e6c5e3bf542f783f6eda1920106cf4b54154ba688a15ea2663291420bb0513d76fcf10249091f94db45aeecaa3429cae8bcedf3a19456545115193ca51b294988d7a0a8ac62f6601c865050cb2121da494e8cb19b25e4c4e9fd1ba2e9c82127d83bc2b1267aff666442077176dc54298c37230c7001b9c6cf62a3eda8e8050eca948e6f08ffaa0bbb293b3f34a2c159fc926e764b786c4f49535f1997ae6084e6416e99bed75f02be2d52c31691d41470342ebea45fa1804563a7e0e0a04f17efc305710e60283e01ab0c16d736a41b345f7821216333173bd0625959998a5bec86279ec49270817c8f7ad6603f75dcd73746aaf72b3507fd440d09f42134842e8b6c2d5612ebb3a0b8dcee91a5b52b3456348814260a139a6c4a926819dbc867f7c4fbd17a7ea28384f42b5cad994244612b98e1e5045b3feec1424af67fbaa5deb3219016d535ffa39ef600d637952398c3bb04cc3d70632a97cbe2f6e5681545422892de017fa03309375173e3e81bfe12320da06a2c66b82b0a35c3c328020fe0860e66244243efe441ba71235a47b4fd02c866840ad351e29d7aa9a03756c8cc4602004fa9767140cb8758fbadccd633cfb59a80599302ae096425cc0ab8c33a5e55dfad4affe34c7e1b1ffe185e8255b9b9cafef6a76d2948e94eb17d8e7e66a1930a4e4b33d4d997e4a7160c8c43f398f59adb04554b0435fd4761886ab8f90873903925b675585c10a6dcd4cb312a2ce0b2b8ad59e75280c8ab5bede3ddfc1cd96ef010f62be7f752bd746d413d3499d874d02afa83210ad643327a508fb348ccf54e1b16a729e315dfc5cdcf3be34e5b488017bb3307110c01e534ddea894585a0cd432a905c7a0fc31edbc504139b7b4d5658a3dbf1181ff8484faddb3a3bc3cdbd7d451430e981dd9aa8d3561ba511f29771b942b7fa20db1654c70aff4743d3fdfba8984d3260beb192c8ed8d03f7aafa2ce59283934b0fa30bd5110fdb1f2d7792df0acab5db73f30a600e8d7c903a20e76ca9fb476b176fde5ec9bec9aa6cd0b4293e51558da7eeda79e34b2b7350959a4e031a17cfb6725688cfded4b2604b78d0951a6fe8db53883feab643fccbcc2a383ff13df84b0ddd1f8bdd7fa955559e27bc00cf1dedf82f500074b64f52061fbb658846f7f31a053a83eb991ab13a6016ae300e6f65e49202ad468c36b6d665e2ddf42fe2b2c5cfbdc19c2f8f28b874a1b6d06092e130d6e93362cdeaed34b53fca4c7de3c544c5fa6b0c6514aab01c98dfc206ff7fc31398bf7c3ccf8a54747ccb826914f37aa77828e16763e61ba3d47af9bdb60e6aff5e6eb65ec9b110f871e2ed2233c0ee448394412c702fd79a7ce997d4c06f2fc321c2d3145e83512450d515e3e7b5a4acde02c8b8e7149708dce0aeb0ab3e41f5d5b1429dc1926c86a5e91e688e8dabbf9635e1897e66e3818dc3b1346ad528aaece94f9f4c28c0d251ed8983068c45fea0cd2241b42e25d6b5933fe2496f6dd51fd71aa12eaa5294eb7093fabf3f3672b14fe9fcab870379047effaebc01f50654cbed29d73c8c21e8d2f863d120703fbf8e01672e5b5608494e340be31d522a8093be0fb43a5303b34f42b7d7c89baf8929cf8a8546cb202fda41a993c33fbf338332a8bf165b0dd63ac18d4f7bf7ccb7b2787aa629f11dc90889bd793a6531b3ff85bda4f3e9e51ce2ef5e687d20d83bf9d89135e40fbedfeb72094d07ce261d5a3f99f5d47e0e228f7a464586b35c6e4754db5c9580578bb0115cb341a63fef111607417561bed5286414fabf297b0d707b0d2301369d92df9168be09f38e36363e9bf9d77775931b2a153f2551016531c74a318783cab3b9eabeffa4bef612a13e1bfd0c5a48c8eef46e8733e910d904ae00a4a10f82adf1d186a7294cd9af0bf0fa36b1064c9a0edcb1aadbd5730dd5a5a3b7c73543f3e4b12c0c524f97f0f83158704bc92673a34a320233d28d68adf9734f800c6fc9775a76ec84fd4127f5d7de272ffb3cf3d4883ba7173c998728253b9ee98ded49c44870ff45857a76703357354d1ca2af21ad1be9504783bbebe363add9ba3fc76ce35a9236602230fd1eedbc53ffe33b0367987b2cae550f550fe88333c43172c9efcb0d9eec9125348a20c9d9487c8483bac29e11dd6fcb92cf34b0d46b5c93d0c2c1b04d140dedf5f30e910b0c7c9c0fa58e16beebf464567cc7716a21a71e72a5211e3e36811f667d35fb344205c88332bee1883bd64d1979df5d99eaf37755516ded6f914d43e4ec33b117d61765e51103b4374fc8d61c01e9cfbe4e2afb620bc41a8679904d191432c53d8211608fc41fb8055ee48f1326804fbbaca320f23db5405dcdaca94e3c583c996b7df066da1c77ebd4a5f991fbf710993d8eae6d7c2cc920631fc9d762eba6c8cf6596afd8cd7afa1986a3c399fc1e81da562b3c27e00a9845aad02b6203b8cc4b5dbccadc5adff5869830f239e060eb7554b05b9b58d099be1b4ce42ea89832d2f18a9766664ba408e823d3066f6c11d85f8dea6af0e4b7e0020ca044feec2e8f8589b5af56700a317e94a22cf06e431a7dde6de0fe285ea29c152b8dc4e6854cc370a9855f760d37d5be9fd98126dcffd8d18bcb125eaf5bda974d213c2438ef0ea802a3cbb4407c5d241dfed8cde50001d6cd8b3a40e2a3c581acfd2115b73a6769264414e746854f4755d6c4a183d509cf15caabde220ca2470f589835124864f16f87170ef78ca3121ec9b0b6aad322a465a0cd178b50fa5ff696d5b7a91c5b68917ea67f33febca98a0a80ee99e7aa2505cc6ae54039b90f88adfc959aff4a9ac63958065d202f12834aa2c10f74899c7e507ec556e513967450e45ec6f1366f5a0613f73ddc04cc1e444a9fac3bc603a9c65adf9d996082039e03d14878005d07ac229ac4a793dfd8a86d8bcd221f170e5f15343d6962f6cbf29322ac5b961e6ffd5e9c4ba40d61fc098df22995dc8bc53e7402d7c69e6b5c8c3ede924345fc9af276f9f48a71b5bc28c49186009a85e64fd1ce32eb9e19dd430590d22c3e79d5f00c5facff315c574ffab62fe617fce0737ecb1d11098cdb4ea904f9ebe7c3bc011b18212a6e3266d3f8b3e7dc58a73fe8820c74c711a3ebfc99c6eca0ffa4dcf81416369126cf7ac8af47d78a4456235f4d79a24b4dfd9ecca09c9f41dc6d57ce5b1fba15152ac3bd6f9b404de3740e6af8ff63ed3f655f36c09fdd21cc699ae4d47d8efd5a840cebd0ad982150c4b1cddc519aeabc5cdf17941dbf15df7f5834d95fa627133ea22e7d89e22238db0ff20d5581de60964d40104bdbea01020a3137acf26be99f0ded851d6fc2d9b1e2ca5d7b0f9ad7707a88b674254c6b3298680b4b2df03d32bce313dcd7418d78c6e2a6aaab2d28643fe256941ce22b4cd29a11fe489051fee0ee856f0fbd6d64da9d3fe2eeedfaeee82dc44732b776914f0f39939fcb9f4495599414dcc7b363162a23a615ea62018b173a323e0505ab6106ec323a718b18f1bd01713ca820b6aac5c353a51a9899b861a9db50f941896a98eff505cc791ee46b40e22fec409a1e6a2989d94ce23534995eb6e3707dec197a6d21505a5ee4ca63b5baa8de139775528c92a614f532a91e232b44e6eea67e140181dc283f4c54b7cfa4b87fd669e24039182a50e1fdda00d396799d8315f75df7682111f18824dea839d08c0fcdd5b09c95224afc65f120ee11115e0e0964a840fec9db2879422aee2546ff8f774f261da55ed7b7ebe54e4e811f1daa11c440e93274cac8ae1d8d07740186b94d5e6f28daf210563fb34757713aa96192ba05ff72b366873a6a7b8f53e16c7a7eb2a9fa4dc888ee77251d031c53118471d3dbc4886e9d0a70715b5f753ff33881a929813704eefdd5e3d25f29b32181e922f35ebfb1520cdb5fa068147de188941dbe096001a0ab0fbd920136545c868bdffc5347d4413badf4601462fcf9447e0e596ea15bd9587681158801a57d56ab5c04e2a06f7e9951f17ccaad5aaa474fd6149488a17d55a670fcb4c949dff51d720b7705254cab566661ed191a21cda984a6372e55c50750800e056e63c7f5618a41a18fe64dd18a54aa14b999b6d8262165fb3888ad9cc0ab03f00d84d810f6243f83eb5b1406f378eeb76d8d36801ab6e5243c1b22e53a2a93b865f8a36bafe50d944cfa058f418c74f4f16ab652cf89d8982ca0784e6d29593cc1facd55c16b7cf5db3d0f67d058a0d64aaf7029bd1151262e94e4b7cb65af632c37bf0d126a720e4dccb16ec1ce10740ad0ee48671aeecef4b67dfec56755a379bebb92fa641814088e2920493901f2f8dd807037c701162c00eb27b60fe6f6c3bbe7db7243222a83de51394bea7b20dcafb76163c3dd30a9ed7b24643770cfebf56ab28ed704a8eb2f4b7d2c8f1417888952bc4efad6557a8c7e35f4675c6c0d5adb1e5cde0c6219794a21e51581429cec83a5892f00670b249e4badc8556a6379ae4080b6a133909faa724669cef9f9627a8ea34cfee52d8943f3ec93e4bfc18225d6647c716c4949cbd9edb5aa9a3d94d9338a6f9c5240cac1049e867bc96e520932fa5d8794fa3851191d6e146bbcace1666fc52c9f7e518c52930bb588978343ff206255645d1aa45d1e6d8168d1a29955862099c3feb7018b6f0b606de38daba5d1b68960bdf0ff607cfe6fffe000e6b22130752fd7d794c0a97819cf2e710dbe21d9fbafc79fc05df43f3595127acead1689f81ef7df68247e6e6a5f4f7aa3cd028a7b8834cb2172083bfb194cde48ee73404fddb6eb7b42055eedaff9a0a77a393827c498fa3c41b92f076efbb0987dda1eb75efaa9038ac054ef2fa2817c83a0dcdcba1786cf235cfdb7486129e99f03d3a83f1264751c60cc8437edbba5c353bc11ada84818d9e11c87a342e60e192f090f1f8182d509be7a553cae7b6cf640bcde282b63da1006cf2e76915b8a8b5afcd12c589a000e6df496daa188358912726885a0207976744aca5152fa99bbf084d04cec1212cf6f0db5b71f515b58b63cf12368d22db05e98bf48a3c157a7b625855dbd132f9997e7514e4e143269892d8e95d75a5add7e4c7f167c5150423714a89b23b91fb16cab58de1565c5d7808bbda056c10f8514a0e210830045dc4d2c2140f0258a287760ad34418a50cb9077ceef345532e66333b2f6960dd1c9c9b27f2b2c94ab32e431fec344f96526f09d1c517bf62648e2921989063b4723aaeb76eadf94fb4b722afe32470dbec57721de99c47be9691942fa1ad4a82ef93504d0dd5c7673af2825370897447d18a5518b21280a08853db8f835e3b6b7772144014b42e404b843bf48eeed43a19b59bcde3895180610a12d8950c616829c1c8d1eb6ce716d49f4358545de9aa4de659597368a493d56339b297a9d02e976065a76c32139a3190cc89f29722f66887f01bc195c0fcdef0e21d861ed6d111b69506687a3e85b0248359551a07b12f5f142e13f4387c2a17f9c10ed6da838bb90966acc40f71239dbe388d1d62d6717c471087a9718d9e191559913fffa453876c6dd5575000183894db280a3eda83987a7981a4f1e3764085c7d774095ee0cd0b00e6cdb788f749c7a4b6411e332661fc2f5c24fc4f8b7ad08d46684c048fa64a4b0bfb83add8a7b21604d8fdfb6808d76a0dc0ba3a99ae498f13acaf5238cbdb2ead3fc80e4d13db99ca6e8917f715725342a961d40019ca8a44eb0bb5cb5a06438fbda70f0fb029aeb89fbdd2c28c7e61c62911e153d7f2c79516bb254ccbf23d2fb8e10dc6ce7e9cd4df9a80f8a0c4e5eb3e8a71f306abc9bd592cdba6ccc523d35769478608f4de27d882b3f9b8c8d5c32a5707856a38a155dce8a84f4a6bc9e6e3f644e8bdab85cdadd27f06d3114d0723f52c9c51af149a175467c1647832d92375c0637fcb043c27799d7c8d77fb2a516aeb0b352ae0b7baa4ca71d9cd248a51a3c254507d4276297668f29ba5b342bc8df67088ddf1b57e6505098032a8b3565bb4152e04921cb7f1ffc48449b3f30542b14f9c7eb83c82dc5be4165f88f4ecb1165485255a57601c99a0443d6e682dfacbc467fab13cc477128111223d7a7e4b519e1400ae2500e1b86dfea0849a3fef7be1063c24f8227ff0ede6b5dc3c782f9b735c1607685fced7865674f7d7edad8c5742fe47194b804ac48430ccc50be89a752dd19eee474ceeff815380aaf69b0394e81164042ae588918304c1533360faea72cbf8f4738144f6955be8ecbf58e8da1796b8c83450a8d1242ad917d0bdeb8e0b9da188cdcadeab8abd3cec7ddd1c2bf9359d854f43f36baee12b18d9492b180468ac38ab9fe56f823c8bbf026bce570760125f4f08c4fb6afe73fd331c3a2dc1364623ce56631b4cc96ccaaacd55dea352b8d6380fe0befa3a659e7d31c15dd4d9bd38c84cca6e59f51e06bb33fa008fd5e524c76db8e1d60a9caed82b79a2d48967d5869bda2f69c2a8d9d80ada945376bb8d8cc0b80729e8ff67a9a2c7e3df4eedbf7ce9e577e0b7a7ffed3861839817090383445360af3d74ab5fbcd2db18bf858aaeb55e14b1aadd456f403ab955876ded976d2e4cacc2a7bb6ed0aee4989c89b11b67551b8b5070ab69962e6cdc2885b1732e06903646d81551c86861215ef284b1d983bf968f3583608887948b5a3c5cb473c3d63a2a88b55ae0a093dedcf5afe1f83f4977d53a4f384956bb2ebdb676f6d326f10fddc9283370f9005dba86b94383e9e01a678968382ae2ec397d7fb95f48707611bf2791fb50445a92c32ae5ad0da4c25bd244325ac2a9c0b9a349fd1fff878ba598c841522606e7cc393d3563ff0e14d653367b7672e1629a8e867afda6ee4c1c1e24665493d16c53d6a4d53c6e9df29e88d366ad7b241053a74da00734b9b181cf8871195654c90e70973c9a41414bff491f64f5842ac2f649fb736ef434a1278d527c718f41201393ea0a7420e45c097d6493fc778cdbc66d930e8cc866b5f2406c5377a2f238672978f2926506b724c5d4d7ac657dfd297e388dc3ed925dc2f1ea04ba082d73978541e4d82edf5cafe42ebc2ec4f2dc72fea0ff5de2e16004e6bba3af2b867a000825ad619ed0b7ee1d0af0fec814371493ba68386b0e349800aea96a6f8d2a829c66d20092f2a0690195b1657d8d085c66118b4837fb3a76c459eaf2f54de3d67729093a0911549589e4aceb29c12fbcaa9bbbed6846bbb2e9d14cb16c5616d065d199ccab786a8d82bf25ba96e02ac347f180ca40fbb3c76e4c24fc43a17bb358d50a8f644395000ba9a91b6ffe3ab2ca895deb61cf338797b54d8e4587054c3965a5ee8e4b4e2e5d3c70e9bdc165d07edaafa344e14feea37d935c6791d1f49fee889f9d9edd2a1234522571e74820d2b1e9c766a5a85f4c60742c12b6cd319e929931377ae0dbbda691ad97171488e97d4b058e44841d6c82bcf4a5932180b84c0da27474a45fd5333ade31d91ba4595cc1cc71aeaf91e56832b8b3878a15807677f8ff6527454f96cf0c868c7ae1854455f52ca5be4bddece2ac12e91a104ef882445e9f0c636a944fd5896800353ede5cb436fd89068edb6336828ca6f3b572c7fbfd0fb81d828f1ec2ee3d8a341f247fe4ca1cf45141bc364c3858df72510ea92cda259c8b08227f00aeb9ff50da6036aab881a1026770e303a858ed8c255758dbdfb9f50ede54577d42ced32b9301d9711b0c269dffae74c32f14e2bdc88e235753b8fa22e5ace055144f9cd0678ca3bd0ca0ffa6b17bca40805b1e56cb2743c6dddf81758e175afde7e29e1533d0bd07747b2c2795652258ce207b06dcaea70d2d746817dbd4f48e722d748eede3d569c15a2bb5f3e5e1e0d22bfc5a1a5c9eda8950f7e6e6b86ce68468319a26800b4c0287e59e025aa0490a89d09f611ac06830a12b59a8b415b98135c6429ae2fdf3726e4ae035158a50c3abeb82378bcc556a5c9b7dd001f58e43463475bf3d5f27594879663ba06cb0bfbff2afe41e58e4e27871747f73a32a3a1f6d615bfe7472b5ce88c8eb30ed24e7ae46c538ce575991cd5d813c4328a0e7406ed1f9061fbf604","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"03927204eb1d5fcae828dce4958a3373"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
