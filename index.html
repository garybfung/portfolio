<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />
        <link rel="icon" type="image/png" href="images/favicon.png">


        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
        </head>

        <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
          <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
          <div class="staticrypt-page">
              <div class="staticrypt-form">
                  <div class="staticrypt-instructions">
                      <p class="staticrypt-title">Site is protected</p>
                      <p></p>
                  </div>

                  <hr class="staticrypt-hr">

                  <form id="staticrypt-form" action="#" method="post">
                      <input id="staticrypt-password"
                            class="staticrypt-password"
                             type="password"
                             name="password"
                             placeholder="Enter password"
                             autofocus/>

                      <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                          <input id="staticrypt-remember"
                                 type="checkbox"
                                 name="remember"
                                 checked/>
                          Remember me
                      </label>

                      <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
                  </form>
              </div>

          </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf76f6f5fc36d723ef4da3cdbc1989f8ebf8a75262716bb4bba165d516199157e0bdfdb2bc99bd2b0e4b7d6ccf5cc56c824e755718ed02c462cb1cd889f2a27881572078142a106a8663429feab5490b92d7ec8797c4991092fec42fca4a8faa74d1d0a014833af87cbec11a98b8c9687bb8509863b64bbbc0dca6a0e3b004570859add0cd7eb292aba0f2f76335518e6bcfdac663a8debdf7d694cc15b4fa58bd368f863ef14531a5abd17bface6d56513ab5fecb02b4ccf0ed4699eb9058d840ebe00293cdaf208b8408c042eb729f77cb75d85ef7109a8b67fc14116c3ca7ada779df420a27979d2fa7673700574fde59e04f52605a1158eda97b3496f48dca6ff92d4d01e1caa9fa94fddb569b177a0cb4a8a9b99994d49b4103616592a1c3f6aacd3c85913372cd99ccd097230671ba567f15050fbf23da667cf4b8bed41b8c882b25de0bbe431ec608cdeb5d833ce950191a4fc4dc0368e74a6843bd7838ee26a7e837478028842740a3c62ec7e92ca03bff0d3f5b7c330644dfc581ed490ac3ab0cf5582991f37602d1c41f57bd0b72f9953fb0d6fbbad433e1f63737cf233728e9ff8ee48a8f1a1210b03dc01c3168620c9cd854af06dbc37fe81a14787a1fa975196026e8bfa0b48fceb4ac5c854622fa54a726034d1fa855cd312fc51c562ac3239779c97c6200ae8a44236742248bf7bbd51622963be961e6c278dc83e94b81e30f107a9974b3af966026fee7b49d554b6d70de50fc4b20a08f91971828647269541768733ebe4bd9f42e59db1f10d8edebc94f4b183091927ce48b3b1e2bd2560b0857b92b41ab9938e60fb585341d63d3c54c964b18ba756549c690d1b582c345e094582e3beaaeeaa5dcd46278bed3a9dd4571e185817079eccc3f8b6a77e7efff26c4626e85ec4b47840acafd0a844728808a53aa30c5e95f757038359838fc49a46d5d46a98c7bae5742692d11d22610fea9fea43287b0992fd28316f3bc9916e1a0507363e30184e347c48f11f4b0b96b801c23297acda31ace8df93633da368232bf4452fcda93ca4f60cef3e6606b5d934e2ac5dfc3777cf5b2b4dec146436c51861de2ba944c22aaf7d9331b48fd4ff9ce2bf6502855184b5d48a87837fa2331b7a1e591dbca0f60d84b855e71f13e28a38f069df4dd1166346c22bd466499bef31a582837bc2029dccd728913c5fdd3e93c0799f89eaa5dc2f17b211735324539233263fc3d0bdbc1d01f79678e52312665e01be74f7a9d9ec1da026a2e892b106b20f3ccdd2fc9101302bd01b7c4fb0a27e12cc2c367e8e531eca4873722a8edf787da623f07a7b0e88c672ecb73276c765155380dfa9c8e90322043e696821e342bb675dac7861ee60ea9c38673675b6af36bea024d5431f16f62c53e05fb2f6fc8dcf2d9760703c3945c0885bdf9cb94c51348478866687931851e197211a64a791fe94a41146b14dd815f5bfe73c3a0bd014a95c80e51d9e0676fe7049372087485c77eb419248ca25570ba5b245c0b725c4e343b2955b87aeb4b7bfa77d78ce055e97028a12cb119ee5d7e730189d1e6781a87f486fa2e970a49fcac539c16ec8a782d25c7542a280f38f542216ddcf71dd3e1ffad85cfb332d251621a35ea99138b93696fb0af50b79d859fe6aa27560e75684f07e49fb1dd499512131b6bc837c1bda1fdefa27720c6722abd70584fd316afe634bbf76c36a8558a37675645a1ad60b8d15bea1bc164a033965c04c3bf2cc6cc03e78d5c3efdcd7bf0f043361de50b67191d88ec3bc17b3154274d640624ce879a706ab8425a1aae4e2dc23015953b0e915d2e31a901ba4222490ad4a0a3ccdb5b3fd386761c6e0cfcbf0034957cf94ddfbbc7ce4a0a0b77dafc84dae9704485d7f6fdc009e577583ecf2b72dda61958681a4ea38095535e9b614882e0c577478fc4bfcdc66dceda9e3c5b6f45368e3f26d4277991200b48f6ec1270136487d4bee6af8771b38c83b181e557e918dbdc00f199686918f912d17cd9e8d8d72b93e10b4f052301d95de4b630af643c5c742bf03d4c492b702e5fa414cbb4c287329ce8b88dad7d1755e26b1bcabb0039dc62a25b32f8e6b9b8e6744b64643f74ed96e7962e9f56658b055c9ad4d63ebbd8efa3e60636fff4519967041d9417bbc17b62636d8d466785cb5d99e4419ef1334c72dc55fb3bb85e00c7577147877b362c0af91f47bd24bfbc988825b0ba25f6aca84d2255769e2dde41ce4be10dfd0bf63439653afca7cc67a1a36f55d86cb1e8edad2f4bfaddf1282ede68288488ddf2dfca53e47781771530cb4a9d99050e8457b6bea76622f105cdb2dc97fab871be5886d204266a1d2a2d71d353597cdab38e7b9e3eef93f7d2069c2895d67d4d8eaf9b12d43f93a7859cc96ba1d67912517d9b36a28fbba787b8310955b6c3a2e628243f5572cff18cc332cc632a71392cdfd9720841e0d515abb22445e0f43e2d7bd507fd6b4c26bb1fc81f735ed96e5740499dd0912ffde6e12d042c9740b50dcf5dd8d20d2a8d6a87a2593df6679935e579ba8aa9e9a984c7b2e74b883d09e125cd8f2271da3675a6aaf50dc7b28f418878296e718788e8e3d64ef975d47b04f50a8075d1ea86cdd303bc5626e5e8582e3c404ae2519a1d2e470e7a2dbc8dcf8ccef95d41853bfd49784bdeedbc7e8f3fe730dba71f91146352f759bf099e5147be740ed28e21c6d6391f9abb0ee98c9872129a1b0c0c69eaad4980d63a44f39fd91bb549afdd7f8c0b36445345d250deeda2a3c52d878f1b2b45cf6baf48ef792514c66e613a66555b68e2fe1c15bba49301344bb66ae1e9120a5dd7bd8b723f568f74bfcc74e2e76a80edb10717f02014aae65834eff4f64359e7e62ae3d8e748f24f8e20858c4d7126511acfb9e1bc204309a9b2be39834a010946e9fc1035e978acd814d19399ecb60378eebdbd2b178d4cca4d31abfc65b85ffaad2158e31e566e6a8a174b9101dff59eb952ed14f8ebd5abf05095533c4b5d7cec170556d87a09e14b8029c8fd121c3b3525d11bde3939859d2e00bfd07b43e7479c14996162fe1fc878e5b6a5cb5101531d69a9d42bfacfc4a16f52d1858615c19ea10989fa81ad2ef7e62b924b7fbeaa8772e3a7fdd4f0f93a14c0af1709261f1afa7a4d48e9e1ef6fdb8e9332399b9281d53f191f3d9193a0e3182068e632459174ca1667b5bc67d806af0cc656f3d20919cf8741fff1a29c6cdef844702f2520403e93e1c0209537ee67e13a630936a67229c8ee673496272185e4a0ec3e969c1a91d0655bb2263f311c1b52dddde08a3846d55f511a5eb78f82494fc87a2e9bdb4fbb46d81acae29e1767927a507dc7e9bd071ce79508f69c8afcc422bdca121494dc584fd3b4922da277911c960068df1e18197f68f23c6fa151d7a572302de97b9f5c0f79f1d7f078f9cf3c84ce5dc91ac0bd154ba65a69686e00eacaed1dd3f5e140eaf12301092ebf375f7f5248c27b6ae2388f4b26b6dec97992a5dd47961945daeb4f04a59b38c0b87ce515d69363a18d460f518d2d202f99447ce8b9cc25a0b9a4ebd5373f4507b4ff4fcdd035e4318db04e7c3df8b9e6b24ab8bf475e04d56564ce0282910ff48888c2bcb9ecde5052cf691bee1dd95f5254895ed129b0d99a6dfcccdeb0e58c69cf80fa7e42c2f4bbdce5c3a702aa768c90df6464a9d0d6c98370fc02b9afb96dc4c3b6c51c5fd80048d8e0308c34fef7904ddc0b7211d400234291431e44902cb179062c7a1632df23dd64b82ed0c871a45ce5ae095be91bd716c63cdc905e2347d976ce626570e1d94176f3a72e078a9b46725858d38ca635a0b64923846951041fae1f025f828d2ae37cb0034f6cbeb65673ed7ae9ecba59647ada02771b90e4032a6760577075909603500b1f0c2ba5a21f5f86a47d5ef7e04474952e54dd6419606d175921178ad2a9ba582c55bcf16254b67a3998cfcf5b59032d5f7dbbd1ec7a2733757cae95b6d0e2760adeb4486efe1da5f1a1e16ee8707f2d918bfdb20da0e4c9aa2b0823d2b033be8aff26b1d34029716537dcaac92b5288679cebb8e122fa5ae073584a890a4d8191fb20b0d604d2ac2e70632172f6d7587462557aa3e1ad416700b47d3a78e2f6c473c4ab279f45550d33d6dd6a0bf2c4da8c1fe0f74ab8c0c777cffa324446c45db7832e55703812aa34fc2e613ac23c36be5229c077acf5598fa9878aa0a2095def7ffce433d852889de9caa359f6d48260690996a59e458c37e0d28f5553e6e5f0e61501092c5cf8060737023d6b025b5df3b4aa1e180c2ea8ff2a3495fbb1370dafe3ae2336db5a530ecab5b4d846fce8fd7e64194a2afbc70b14742740394b5129418dc4686bea3f130c9d80d08c3a20fe10a683c64f457b37032c64ad5b1d04ed0451ec4e292b362007fdd32b7168666e0ba255cb5ad9befa25cc5a2805a2b8d59268b78dea2bb795973606c8dd168bb895103c55ce100802ded0168bd30b75d8ae7e9a5e593147235f5239e93b41ac86a35caff99f8bee3340da3050083808616a456af7901f768456940e1ccc9d665474181f5a16e6245758b9f165da9c904084151d128405b06152c8e4294e8abead4105dabd4526e097024f6c903d995f54a97d3b1d8a563fd5130b1da725e8b221e75573fd6e3ea883c57bda4cb15e32b8cb9a11b0b34d001ec8cb2f70443aca0f5efef7c1dc1c6e71ab17bef4780a3c70304dde7389ae18497db5edb413d661772752463ea92bc5630ea7b8e64c0e1f135389a76b11e54d879f2431eb8b7cecaa1cbd46899920a40430adfe7d8ce8c6ad0d0c8a0006cb50bc1090403ae816c32a68b8edb2b4009bd11b081024969150d45c372c5899d34d90324e92941f5e49c13875ff8e9e3590d01930552e37ba73699ea26bb7ad2a260613e4183f0428f9249e998d43bbe75ea2927b8b3ccd227d27b3ad1ae99cdd0c458051ed63464dd2ac96eae84a4862c94a68a831b156f1040082ae55519eb348f19bcfbc7ff6bdcaedf20c71f6140d3ce46f4fd43f36dc9f563315665b348d89668019d15e6d3b1a22ef353d63e8e12ac55ce60e5c16b837d274f623936674abd34867c891b9abf172cebae118ad41c4a8cfc8585cb3ed51f1483534334cf1f7927b76745bb5a15ba7e5555bcbcf7b06728dce8e329adff5030584852c4ee780f3fabcba38750569454c076ba6cd863f594a2cb840bc56ea9070dd3dcb184f3b7794a4d4d89cf2de66cceb1d8d6cc12acdc00be32b251e7d7905c40cbf513419d7ec31dab3bec9f99d5730eefe199875bc2f7694ac3fd679450d58729b6ab666b47ef82e267dff265b93ac4a07dfee5462e65ade77f29683c95edcf1d8d687c4d197e8028baf895df0d154db8d16d42365109f8d2ff62cb2d156b5c5e466de62217bc87c20194c28ce6ee4a105756e4f4b8542e74cde003980bb0aea6ae0369865a4368664babbb8929318c0d4a94d150d64e00d69dcf9c427a8cefc6a8f8c36a8d3bf99046b1fc1d03fc01cf1288259079323ab523a7ba5bd05a546824984ed58fd31768bb9be99486a8ec651af0923bcc596981be3d6b6af0a8b7a71b97fb353399e7a78e44c5ec18c65e4604aaa8db7f9bc80b95596d9e10c32d56fbc9bc8855ecf65c276801a31fb2babbf78d4e473e15eae034d011c422e58f50c26aa76aac09da448829387e5802c71829f951ceddc4393171a8b90386a5f8d867bc855fe684ded2df1e46557713f8145d7425c4570bc51c259b6f05d9412f021b87072687ac35ea4d834a6441ae9e35e13eceb354350f88e6e548b67797541bc16ac95df5ccfce7cb1a0a1a292a07aaf86df7972367c58784ff07b4de06d18ad59386c804ec45b1e25be484bb5357088150e8be04d183ce4a75584e84e16f1b6c6eadd4a90d09707cdc5b69f1349faeca22dfe43a1ef62e23d107c5fac149426a8b686b67ab84a8e71a85c0ffd76117fd7c15e4fb14ccae99e2eec8e31742f96edd7e43c3daceaeabee661788a2c19d51bccec50ecd2141342e8f712b74078952da8f43655475c614fa2f90b3a5db84ec144a2e013a76c4eaa7a8a909d919356f73370d7560648ccb36a4f9f5b1f50d36aaaf92c16266cf9ade545d555dba2eb84375b7f90b832a148d40cee92b86800974bb35cac732ab5da9ffc22c044379966b29926f1dcbbd28d1cfdea30e051bd2fc7b1c9dda9ef8496cf97983ffd5b0f4bb98bf59c8e941c83135c932f51d03b4e5cbe2d8d0d71a285b19df21085550cdea359cdef65c9039255e16d97eff35a1ffa49dc22b3f0272c9825549ec021fa7c87f5309223cf297ea7d4eeab78ee01ecfe339a5464a79757aa43d19e997af2036b8fd9f523b9bf1c8426eef699449c1ce7ff61a001e8443e968cb81042cd3fcd43a3678455c97527e1f654f1d303eb5d937e6d23592a3d144112236643efb71a50838132ed42649e0eacf590b38dd304f3e75f0cb4e1bcf6b6e1bc0ea64648844dd5e483304bf28df1444ed641db53ccd9a368ea4592a728d4d988b7b59254b2bb44fc6afef414e278e5283fce013d4b405f056ad3a286d17974c7994bb036bac95eaafeb598062213be73359bb620004f21eb9f11e215a6d4feeceb8f3de3cc3f3b3ccbbc772c33bac1ff22cb0b4137f2d223b27b721e74290c4826906967f34a48b334b446f1b905a47b72cac6de49a93faa96383e06198028bee0bf8c4bddbd1e1503d735d3fa0498e7c1cae99746382b13cfcae50382635687fa24b0df96c97aaac92129e7d7814e7d9b1e77bd1afca52557f0100b373dcad1a7c7963c6a9a161ec05227e797f1e8fb6fcccceeddde29265d702f57dad801d26e19e234560c40c4ef540c740ae062b71525d0db813af075bbcd0c153336413c00c3a01f9202625e63fabdb48365a3168e27ec612830760a22ee62637f5329a0538a18f5966c52e591ce0aa804a1ca1e26f39d3d1705272b141f77d10de8e8d12b37b31bcf9f7ccf410ea855d151c8e21e553b11366ba80c550898c95aa3cfee8512a458278057ddf7786f0d950907016c341e90dc2910214cb26bb9991901fd6a384628375b3dfad72b10ebefacc17f467c954a07573b94cfca324106484b6e7692aa22e58388939d2dc868b54b3b4537c4308cf4b5fb5d99424a6dc3d32fd3c684063ee6847ad41a3993ead1aba9ab185dc56e348a87de7a6134ada60346185efedafb69a9c57940e724ece4b9a14a648e1517b5bcbec76ec1ed33b5ac6da4d353cc3877fa1507de71045bebcf14071971b9092f609c25407aa8f3e1567f5efda0d089b2c4424619914adaf82713c4d28ee319946bd9ace326650e181044020b96d925634f8eee282c03d4e6b3a6f02ba38e79dccb03947ccd7a354ca709f78942f6319de9ba587f832986427dd25344bef5d80fd261745c0c2d56ba2f307ab05ea794b30fd8f0a7931c5b930e2bd7cdf24bece8d8e15b5efb7f7456c5e22dd163ccc331c3a1834795d3317086f172e0fbcd88e2d2703ee1ef068c9afbb08ea8016558cf2ff2cb7eafabb46b5624911364ba49c2221840e1381f66943c6ca365baa0f85fcf15a2e25c55e4e1943c14170214e38b3a8ac174947360c7b1e2d9e93d60c10873ba82b4d3fbd97258baa45acf50691000ce2ceeb1d8bc6a28f3c4905e65a7a0bcb4b8a1fdd1d39fbb40d84f56e87934e51c64d2c6c5c69aea8121aa15ef744e618a666e763b585f95c6a9de3ed56c53d34e492aa894dcf5200378ccb065a95645a97d11587a6ba53a16c6363dd0a667f911a2a4d24e2f425042f771621916acfad2e7a4296049c6496515702b3cc31f7189133b7a889f83cf676256eb1f911b042c605bc9ae12cadfc69a952fa8df4c9113b9a218aba4dd003b9c3b05ca761dea76673cd88bea6b12f601d294e28861138f6570c0faea82f10ea9dcc7e8ab6b9e3f44c6e8ca917ffe48c7c25be31346ab0775db8cf5a62433992f9ef8fbfb60d0db08af95ad3c82ce36e417c119898d108b8305c050b4803a7358990f9eb3ecf56c131b8c08bfe54afd091e07fa008973c9b0bb7f2402c5e7582c118a723bc28d4cadba04920a3fc432618e879c68b60cbedc1471e2b3148f21d46a9ce9987e21bbcea09222e47633a3328fb09084aa1664ef02bd62713f8c554609e86623eb246b943a054239bfd3ec472230674e6736f6884be9fe999e17bb95549e3bec0796565c8bdf626ec0a451536db6fb903beeb27772a8a0e24fbadf2e6ebe6f2a91bacc908f10e1531ad63e9abbd2e6d9694bc56f8cac97bc04b8bedf6bc9043952dd9492f1b00192e20ded9fe72cdc354cba7e60b3187b6df398fd7a23d8948d8aca2166e293fad50857ae22711b6a9fb5002786f4a8f5730ab8fbf822355f4737f5f34bba565d9f2b96985e7a771158ed20d796df25a4146c2bb4d10c9828a1b200ff98382b551ac60963a62cdc4eb680738c7a139ed65610b18f3cd6807450351df900212568637dc31f05ce37c038818f965f501b4dca6acf686f21f47a07b0aca44f8b1f91c70cec823921585ed8fa5c9a32249b7788612af916fafb34b6b1985d2c427c2e7acc4e0c656e86541f23ce9a02565c7858cf411e957577e0246aa1695db6c13b8f42794b7bb43d0de28acc49a669d27596a026a1d5d94414a9021fffd43957f8dcce53628096b7203993086d609a1a86d4d624469206594a12117cbee40ef641ff2409091f7effc9ef819749251688b061e12b0bc5db9602","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ec85057ce6a302da0b73683ae762fd49"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
