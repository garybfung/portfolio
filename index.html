<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />
        <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />

        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
    </head>

    <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
          <div class="staticrypt-form">
              <div class="staticrypt-instructions">
                  <p class="staticrypt-title">Site is protected</p>
                  <p></p>
              </div>

              <hr class="staticrypt-hr">

              <form id="staticrypt-form" action="#" method="post">
                  <input id="staticrypt-password"
                        class="staticrypt-password"
                         type="password"
                         name="password"
                         placeholder="Enter password"
                         autofocus/>

                  <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                      <input id="staticrypt-remember"
                             type="checkbox"
                             name="remember"
                             checked/>
                      Remember me
                  </label>

                  <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
              </form>
          </div>

      </div>
    </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3ba545c0dd746754d28a7f80ca629fb843206c24b37a867c7f2f3968b480f7849ba1546ec999bb632230b06ebd2f3e833e43966b7dc6b72a0405d6948cb7af7205fd05d5e905663c8b9ac3efaf1f2bd1dfc4cf04352086a3bacedf7c9c99814d9fca7343950caa4d71a9c0b5b0365360cdf63862c86a2ef31f810061d6f3655379b171508720b92a31f862548b11ee0c99f84891ebe01e289add931d18646dc43003b1caddbf518942e9bd92986e01a813413515cf63d565f09e81306ae134968a580d0aa7f579129f3f71752555d6c89c867bc3eef550cd5f3727236b05468bd99f8d78cbecf16dd34d5674c8a8925e1968bec4bcd1022a72904927287545172cc28c9c0c0fbc2aee3abdec22c868d9aa84d9303de2385aaebb59ec8c7eec95709e22cb49525a7677256e8379b1e59d99421d3bf8b2a496eb17fca6faed0214a8e462f168f06db4726441347f7473aeddd3dcb3a0c8b66624e855e3887df76fd34baf1ff168622b44d16cfc876ddf93c9c0ffc2bc1f85c2b4da184568e4aa1d4efdf7c9c151e72503d16603798303732d6a141d564cd2a546a8452f574948d73ee0a8a7d624f85b4a0abb55178b08178df42caa65eaa0c7f73d3fc2d9ca08247de0dc4384e0a6c132bb6d417e6b099641544311b66c8bb4a3f1bbb56a40a429ad0c8bed3d6c4116899f005e12bd239f25db5db416fa67bdbf6640e7fadef2f33086c50ebc203958860bb8d1cad4934a91d5b0e6447584441094d86bf98f593b0be7fa519c3271099fc12a75904169091c3c55cf9ec1cfc47f90e16ffd09cc3a177c800026e27109f3f1788a57bc8c23d3be25871b650991b35f6e844a3e02aa3a02eb8036b27027435bf6846dad77a711432320b2ba0f2f62f368455a29854643113d8122a2489867c23cf345575957ca0b2fbc6384113641eb7a7bfefc3254696bd1c1c24fd4241606c417e6c25cbe67e02c2cf0525c08765c45449b576107e083cb8e3a912f27f94c6e2eea39e79456ddf7840e1a8ee1c00eda54278be831b3b0e4dfb170cdd4bfa9d7c975095ff7218c90c54f37f5680e2c151628f9adf7abaf4f204f8a15968eef6cb50daa0a87a36b2481d05cbc24619a97ef4e44c062958433a504d68dd170dbd06429e43a4a47f194abdcb1fba642c773a273d7ad922493967bc5e65783983d95f071281ba52561e8070bfb185b34d498f2cdacdddc0675a20490588fdd6f7c9fe3f95094ee909b657760bb08cec9adabf09890f33c136f7537df974dfc51ecebbf67336d99a2c434b6195693bbb0e99af47a0d000f97e5d79a34bdd3b3b03293c100912c8d728153313faaf112a5d10e35a643d597eafe6809b07dcef059bf2a19749c137d88f26fa30515045f4b0280ca2f6ff1fa47df429431592d9f3c86a7cd1f9243be8ab414ffab2c88b4e2e16e60f08369a23bc39f8e0638cbf6161d4e1c10fc965c104c6a656d8e7283a411867b31d294216c59c650b4be1f56a4c9edc88e5dd06bb4e224e0034c67184aaa3b0e6ffbbfe855ce73e4f92d1a623b591e408ed761e8a3e1de699d7e4e27609da279f38e7aa871b404299fd513a4f8deb45bd06756485aa408291364efd7264f97ba4802c3095ab55a5180dfd50c151253ca901e778578609b2dbb7631e78751d5bb57b22f3faf91b3f71272331f0e7326f1858163e7424f9f76aba3415cc7d44b08697ee4041802b785950b540669c23258afaa764e791129dc243451a3eae19b7bd2f4cf9121dfbcd30c847d566681e2312c2e3063d35c6ec34ae57f0ec155c730070ca54bd23f378607e3b7903e4713598d317404295cb09840315f1ed943cedb82580b238056a01188ad4dca032b4cb85a65c3b6bdb7e38ced5ae179a99f85c0053984917d290a0aad2ec7f5c850f09cb4dc7bde92b552b97a6b2e6e8a200551ab08463b8b8c035616059f8e9ad11451db4541772658d0eaef9210763d2bcc1c067313f36aa029a7b42f57166bca2611f819feda5d1de18e2faaf2fc1b2cd1ee1140516bb45f8c3a876708e6eb3983b354a72f898120494a5699795b46fab6bd474c29672d038ea353e6bb11e660fea269ce7c2965f281d60720d95b66fcaabedcf6d7b4f033bd84ee747c10bb457746fd1750ffef8ac08666b374c5179f3635aa61ebdd0a3f3e292fd293ff5dbf068645befa6ca5cdc34f04b87808bbc6a73446bb5dcd5c396c60c20ee52e7b4c0ed1630800948e4c19513a64509b6884bd0b85051b238b63a892d75ef4e62272ec2f5ab83544bda309ec8d2cf9c56f03f6c8ede5ca639a18b21c9d6091dbdf1e7adaddc0eb68fa4a53301a780bd221e58dbd3c4fd986ee46eb011eb67cdcf2e69ad14544f6a49e6f979e2bb2edb01d7629a0a4f0d7e90b54cd8d5ebd05d8090f7e1ca527038b3e80105795b9c29ce66ff48d7d027cbf0c6ab615d1b004f71da4f425335678f6a779dd34da51ef9195966d0c0f18aa1c7fa94bd4c88cb001c8565c3679a2a81014c59a881fcdbe9cfcc6486801d076adc54f4dd7b5fcc20820b8d4a45bd003dcbecc2342deadb8d900c8819da11bd0b667edbe839ed5bfaa81adfb60050f0eb138ff2a57bdcd75e94aa641f17e08ae6808d66a78918468b4b2ad6e5ff71a7e9ddf3e52c6e5cb53cc5e310ce65122a847af2930e396004c88b14222a11308c08a1dae81ba7ade9c600b6f7dc56e9c075c0c2d164b466377167597ffc860cbf399d91e034dbe62f41e358988e51dfd9c6646ab0e018209bf3013c317830d866509c32ba8b69c94391f296700c228d8888ac27b133db1a41f9b2b44a356a972c5c8c877df2c05da55e6b4130948b6f7497050a43a83570e79e02e007a1cbf5057bdaeceffacfe8692df4df4cb1c5927ef1ede6dfa6e81f2490217d348a2ff5fcc54c2eb5850d2b4d4eb21333f8d2ef3dac3999039b943be09d09ca7f37abd8c126923dbfe6f6481f90e602359339b89178b18c1a9a19843313080f25ceefc56cf94ff7a2a04d6c1880b9e45d66549abf1351a0740f055b1947cd8be7c3fc2d8f7f28c880910a5764c389ee7a23d3c282e91179d42528c3105b116c649837da5a1b02efc896e966ebf818b645daaacfbbe432944042f672ae75e8fb81f646a74b6b71367856e92ae7a76e8775c2b3134416948aac5381c0164f5c4cab9c5c8beaf174477a515e4b4a4d1e9bf45e03bf3bdc1f44fc001b60a41e66b14caa38e793bcc538d438827a57b37d77056b6417d4123d6a96f9b34e202f53451bef26077d921abed06964f1c0646c30efe13ea1322bbbe58e8b6435bb4c216673a4cfd7f2fa857655360a7c8fc81649b6b0ee26da1a7894484c4857abbad677cc30a00b301943ce3691feb8c697b8a0da75321b224f43a48cbe24c0e688f8c4f931da142a6f4feace580da859d96216dbc10a63c510941d44073b64a235ed683668f9aea7001b88bc59988d6fd46368b1e0f595278ee60546347b7bf24dec655b0c2eb6c6ddd8d577e955acd2aaa0515c32a4ce2f8d4d8fca47209c66e48c4bbf76b96dfb7031691709d2825251d7f5a8cf3d6ceedf1a246d2c42f39e70fddbd4b85b9df0bbb06cbf038b40ed78bca3221f79351037478224906fe5a16d50969bef02be9d074a1fc0309823319ad351a8f01e8f67519e99af3bbc163ef0434518d14a0e04d40f6c5e30ca9495a30c9e7a7e38abd546b71c0601da1d3b60787e2b7226025a0763b6137130888bd6362f91cde13eecc8052e56193bd3b049abae2bf61350223578531f7ae12fbdaaf388c3137692727920ab7e039fa23e95c0c854e157b79ca89805b76506a81898fd50af2da9c231eae03e503de9f314443fd99b803313c5415bc29d2a78c2c6fa327255bc46980cf5d5deb3ec39ae54e0c851d01e5be7e6bf6cbf1b9c867ccadf5f7dd626e0ae24a5f1418fa17c1ec02dda4aae516f8f8802fcf99221aab8e4e916eaa953d8d508da4e65acd5415b3a2f77654c519e8867b73271673f2dbb5fe6e003530f36f88eeba120917dc5fc3e27a984e186ceb627848a1c81e0c50d49d72fd045319b047845538b3cc7418d2bb2fba4995fbf37e7258b8f538720c11ff43d5209ed2d5e00b1d7261797f32625374193a2c11c2857fd7dec5cd87aba369b9a4c63465b2bd64525a5192606495b86d4c081abe3abd36e716d61ffce1d119d5b7a494a056abb7611dcf20d9fb416d56dbeb5023eeb9ef0bbe58c5feb18f454f88916c8a208f5337dc4d5fe6cb29437b22b725119a5ce181f6cca7054038e6c18233294d41065b9d5d3b9a1939b272640261d775370caa406da6391bc7357aa30d0ed45142d30ab6d10fe8da82a3c6527e7c44d351b3d794c1be8f39276cdcdb13942eec95120aa9cd8ec3c077379f49f88c77b2845d62b972eff29ef3de0cff2d4b8963f33d340baeef18257f83a19b6dc6463bd043dcdb1e6d1ee28a94cba03334695670b48b0a81210703839d6b035799b0e9588a8cc0fd7137c34d0be67a7117f8c53e301555065d0104d80901e076fd7cff2ab9516f64ae7c6dd32c4dd1a53b7b61c6d633eb98991efddfdaf1d756a8052e5b53123b6979179f1d6411039679ee7e88f4a5ee6ffbbea74bd7ea9f2ad76707379c7a99d2242b3121a60a083c934337bd78b1f0c935294f1255d93a4848651c03778a4c04d2ba628be52a22f21bcb0e4778da3be5666aebeaffd93c0b7ca9f4596c4d4303e6301d88ebd1e8cde941713c877fc997663b035a39b5418fd4aec99d747511b098e4e361e6070a6294f33b275ffa76193229809d8d6e2ef510a8d9587b0f309dd4009012dc75b5767defb94a9a988dcbceaa07e1143c3793f3f2ba5aefb07d6dad562923f943732842dd4376a328760d8d2abdcd0cf1440ce509cb5b23ab871579b26bd6fcc6f7b89622ed927cb5f7fd0e1e7a24eea5d2a586d5d0c264f9d21171879655caa8944bb174b20eda86a7d2af71ab6b5e9042913407879079e445a17fa32078b2d2cdc43337531b5939f135297e8d821aa5bf76114277b47ed040bd107a699005fe51fd1508c67e6ef5032ecba7b8e5a89f18da3ed1917949120b7bee8300a80df6125f9237558632ef283c66dbc8aab57f0a0a5a3b6a222898ed2faf998fcdd9bbfa89c447bd00df7a333d21954c71f7fcb54770dcd76f213bf0cf41898ea2d807679b3f223ae38c5ba7c84545d7bf45fa98b36b203e10c46e96b0de143b66fc74e2c0ed02a518c72bf91ccc9635968afb402c971a5049cc27af17604f10dcf31cb96cbf58d1960be29e2344346954179c836a68e04f813ac4fd2eff693336d9c35fa55b78dc10efbf26f9456561ec6f8dcbecadacee76d14c41eb2e7599ede26fc107f3b706a31529a5ab8b24515c60b664e04bab746ed7477ee1688045a07744bd36f4146d846e933c14f0ee36c9fcf2d332d007fb98716d6242042405a2a048d3178ce48656878fb58d37839bd2e649a2da9427a75fcdbd14a08689af428190bff0db1ee698f9d1757ebde7120fd911e2ce65effab358c48d56166aedf99b33751c2f157e013fdcb4c68340093d331190a4ab5403451444133f2e26226e28cebd4e2e3039396f1c0b8c683289406040e093599e0c8fae61887679db585fe4ef2421e8559c530298a2f0923e3fd11301472e7c7d6e078b1cb9d6bc135ad2a5237e53c20a20d52c2fef707894513ef17983db86cbdf05356dee5892167fbbf79a8addb355dea175ffd8ba7df0bbf3b3dc5d3d5d880468e0b03328a7e9fd1be4a8652b3b7181ee877ee72c0112580e67dba3242bfce6447607fac7361a4e001eebbc62be6eab62008764bf78cfb4817ab0a206f2f072bab61326ae626e7cf87b2574f5d333bd1e4c13eaef76def1023fb3e49b614f3ba797003ace98f8cde0dd663ab1944a5f963183488c0ea3c1545985d4e4096ad32f5c0e84b92d41fd88942a51fcf1c7bd9a4c6a1efdcdad532504aa408af253a8162a8eb4af543b5e951b602d397096cc04935c5b1c3d1909ded9f39f92034ef1273749619ba9f2b5c2220b2948b403be59f7d1f98562235af05de4c0a9e978c59ab155f154dce36e7f104bc0df498a2a19d40447eb77ff696eb21131370b343d13dfc6b05fc2bf9ec2550c4c9f63e28e17114637dbe8a9a9e1c248c8d8be6358a2c1160c9bee8ce03784c491c8ab70e47dda2bbc6c32f275477df105ff165f31cca8b38188e23619760fa6c0adc0c5efdd86c74340f8a3c44dea834bd3594dc47c611a6f4a502533d8084a3adb9543d017f2d6cd6dca98bd7b0e159126fe6ad16d39c2c65b31cf95d8489c303bb279128f68d16fc71bf63c069cdafa653364086aa637592fd3008fc8f32f28be40f7ea9588d5526ae89a4ae98f93196283c19eaa40019ac409cad1a8ab9bd96211635b5cdceac6bb1064d512727cb6b7e67fa0e8a9669a221ae2547e511ebe2aad669d36ad76dd47329e7c7ef21fac17df727bd1be30a3e37146b404768a2d4c673d9a927befaeee1e0d9bc38c3288ec7a708e791832745e33b4501239083ddca56b100511f9324af067e16f88396e0b78547894ab7cca4e2427c101775b7df6537d60a94f6b508bd10da18dc770e2ab0c1f04a0c4df9a98e5822921a28d0dbe5602cb1c6ebe576b52fe4b85d4e00add6bbcaa18fee612e00b9ccfb5d3f696d0e25f94b59ab14b93dd51268e048803ecf3033db9d33e73dbb3936b26f59a32f7871c0ed7896f4ff76ca25c58067a2ddcfdd1f369fed391acfd0e8544f015adf822dd0e3e250f8f55ae7cd2e1db3199707ff17ce8532dc47db251a53694f18908901ffe9a7089ad5a8593000a2b4a85f586abbecbffdeb3513122a36c9af89389d8053347b274b2a3813fc4231a6d718ce77e36571c65fe013ccace1434943a34b21bbce4b68dbd11c2e0886eaa699de1f945b6e51520d71c4f2631c828beb500172978809acc3695acfa114089bc5b34f6618804e8af35d5896654b46ca24d407e9b3f18b5d5ab597c65069ad194641eb82c46ff962566c269511705a77bc00ffbc9ac2c82005d0a003fead11ba96307b3a40cf40ae620e9ef02d73eb3741e0676ca56102a4cdb63278cfd17fa2890090dab37884817b2338579e8b85a4b379f0ba3db50a8192d089b625ffaa70d4b2aac4ce16ab0eb7486b7ae7411ad60b71db3688fa06055dc27c64b2507dddbdb2c3da32eb9ce5d3e72a46e5aad86204da4195293763c640119b0ae124722b820a87b26c491cfb063c47b4bb3936067a834e6a804624605abc82bb81404b8d4bb18be9b7f2dcaaf3a15ef2b4b76eaa7c93b422c278ffb7cc5ecc3d0bd017f48eb78e7fab26d908e15","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9c3a7e00e178e10265d75e00532aa7ed"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
