<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />
        <link rel="icon" type="image/png" href="images/favicon.png">


        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
        </head>

        <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
          <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
          <div class="staticrypt-page">
              <div class="staticrypt-form">
                  <div class="staticrypt-instructions">
                      <p class="staticrypt-title">Site is protected</p>
                      <p></p>
                  </div>

                  <hr class="staticrypt-hr">

                  <form id="staticrypt-form" action="#" method="post">
                      <input id="staticrypt-password"
                            class="staticrypt-password"
                             type="password"
                             name="password"
                             placeholder="Enter password"
                             autofocus/>

                      <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                          <input id="staticrypt-remember"
                                 type="checkbox"
                                 name="remember"
                                 checked/>
                          Remember me
                      </label>

                      <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
                  </form>
              </div>

          </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd6affa14460925dd9e8f7b1ffea2229018c08ad481fa475e546e17e46c762cc3f4a6f2572f2dca38db856262b347d53c0f512eaf5e50ec537ca15b1dde32c0a5c1ebfb29b49431358b8e3aca7941df82493a68c98cd77176fbe6b06cc59243c5026b7a543517aa099ae6d8c2800487d52ac313d7e8014d670aa8a99d205933a7adf34c851fc41f07e59a746f4de979d089b97030cd69d057a0b74df181d0f67aeafa1684a7a25ff42beb0d450b31c38f404d774cfda8274463b5b951d3e4d71e5588afe28863ae74322a9d2032f168e8f6d47b10b9caca8b05eb93dd164827a76a3a33742a11b970efb2008ab0d02b1ea00c45bed5f9857695a6144ebfd67bf4c6785b4c73f9a7dcbbd7986176e78135aabb8ad684bdc0d84a4a385b4d2783ff257381477331c299d08c0bd43c14edcf3de331e7c972514b63e0d4577a32284938ba79b45d2592416cf457489e69ea0df3ebccfba23b67118cc97f772241ba846e3f61201333d043a6aef8af7b09c19f8d7da5a9ebb0d1f015e1c858139f0a92e2b247f565f5fc88c2222a2202399c9608626a7c3b0fe59c32d55ad0f878d36b61e6c11559b3ffe752fda6db493cc2a14001c925805d1eef8d790aaa6e043c31052d623e2b5a1054a98d96a724960dfd46cbea34e990622abaa4842f5a3d6fa767fd24ce6c61d761fd84a1a4317333bf9017722eb4b1c3688e8e51dad8907f94e602c526833ee9bece9a188fd6b7b276776c85ed076038140a60684417b3f74fe5ce3adbff455276f94a104aa502d840fd2ec86329910d27bab4c1267a30b5d1bc9478e739c9d6933e67432fe8f472104a2def6d9784253b6057e5cd731b07a9d2bfbb1f5a2bd24f2ada2a5a337d276ef0ef2ba29b3ba0a893056f18f64b6dd0b4feba8c884e0ba11212e85a6484027792f7016ee533f7e0a47c57273a272d71702bed8d23eacc0122b88d0a7965a25775b9cfe67c53f3d3ada4ec645062b06c5fb43cd61d24b7a80fbe041bb1b3e30487cbc8dd02078b6a76e096d27e95caf851f342f0f32530dfaab24ec01579dbdca4ae5e4c851c818132306b48fd0762743ca614bd9bf6eabb0b689fd5f2c3e49951c2f3b2ca848e2540ee4263a09225d996aa8f9252a525851ca55deece4d223da6b5954a454339a4bb9152f5db4a3b987b276bb210331f520e6cb12158af03a2d41457d42c1fbdb30b88e81fa7023b4233cb2dcf539979e09c676a5efb3bcb73946b9e2f29a4d319516cbd4908ef5ffe6d41aab4eaa369175de8259e257dc8228bc64dad5bc85e7d6d7a059d7af4a2ecc0a6ff306c0b4a2fd0c00f71f4c16fea09643947c8ca6aedcacc51ceeed4ba0a86130234b24d5d7b90c205603839cc248104c8d74ec04b05f4a4d1632d376d59b1f9354faee54f6fb155d3edc83a1ee23cfd75c7f85d7c6c0396d21a99513f1285d1277a9d2a0f6c522589c47880b9a22778f7de820510d629c9183b6544ae5b3a49b1e85fe50a01327554ab2612c534ed7b37d770489b745a8dff97ebb10d37b9b162373bd162f01ffd39bc6dec67ea826a2fc2549adf612f798ef2ad5ffd4d8ae8e484e83776206dad68d45305c284b9e8c8a370e6e488b6323266016348235fbabc81df169a369d3d3148db647a0114773533576052997500e6cf678af18dc264caba5a0ca239fa8e59e4acdbb8054c600cbb711ac7a9d37266d88f33f0816b94a12eeb8d31aea5c43b3bf4e2805b8f7acbe904d15a92f3ff709ea8ac50088134450e5e419bb8ba7fbd461828756fa4a3417fbadd6f2ce8c3f4e7a636503da24440517701152cf9dd961bbb01e5a91658426d5ebc404ede795cd625fcc6efdaad28c7d64156212d8cc2da92b5f1a7658790a8865c96c91653c5715e6eef5708dc0d557b0792b70768a720ad8da65da5cd7c2d4c9db8f0cb3da1ed4e7aceca9215faf386a20edf42065c26b7cf566b6f40a5a1e9d41471817fa301cf097477d8db43c8489ffeb194388440bcf6d9e27932207bab3806292a921dfcd8579b007089a34cf99f27c9965ad93f114ac0d1e8382883ae7e8a1c7b1e289e9deb6482a4285a3b32c62a71cde8cd99f284e9e1f9e0574f885dbfc150df794c6031dab9d657076689a2e5bc7414c590f8007063294ff3392131640e314cec2c7d027be2b5b2ee353e0a5e7be66a1facca7329cfe25c721f4516dc3c4868488b90cd6e6293eebd39d3d09627f7fe27af511aec36ebe1bf0c4937fa8fc1ff264f61397c41dffd0d852af760b01d50d1ec4d7f5a1d2a2c25c8bd544d48ca458b9650a24a66860dddd5ff8a166654dbdea428583a6c17a40735570bc10072a8036049191e1b326344020653e9fddadad974ad9da5f5afa341b45f46bc21a7454722f5be3c277a5218a1a89b83e2d60c071c4ba2367d1aa1bc39ae047ba3ec38feef7e88de96e07b7cbbfaf3a0b25e74021725d47373520ef14828136a98ffb7eee4f98913fb10358a4c7a29dc547cd9b01c742b64a8cc758893bc9ba3599e0d19f0e25b92f32ce549ff5ebb70f444f033a58f804b0113be73a5bbf1b8e4790a08e23ef5ebd938403d1480d89ff0cecd84e207f0bc2490cfdcc11bcf6abbdd940c0883801ecdf8a6c0633a8f00cd77550a953e9199b497b608c75c6c46da09591d6afb9fa48a7bf229a77cb26aa6c197ae2a3c83d00560417a3c5490b3015476adc9ec2d85a0d494a13a5d8f5fdb5864bb6a528c20c8aae94df98a3e0fdb82827278e3eaccec414dc8e00a0a8e5744622bb1d3e546e2909a0cf2e955f95c87df2ef1870ce9f13590d1edcbffdc1b610c703e78715bdcc30020a0a0e62c4ecff464549ce1a32fe54b5e1ec6840985e44da3605ea16dadbcf1ad65e04f8b1db2358db66e2b2036edc1b5bd939c70e4b528a0f7ecc01530d1ee644c179dc3f455665183e72abef2af636a628c0a7fe0e18bcb3e1b2b4649afbc285399baac7e662aaabd4397faa437606ccf92db311244da43b0da863452b61b411dcaa00b76c9590bff9e91cff9e8d1457b25b74875099b0bdcad20df336f2f2ab1b0e102fac55af893685f89e8235b0dfe794ff5cee07b7a25f1c8a77933eb2f1806f3ae50eda2f4acb15b512f50fd6af48a047dc2eba62fd4855e0e017411f4479ac5f1aa5024f3b459196dd58d0a0d9ca05f73a0f2ae7f15c161e94558f605aaea6ec2640918717813dbfc3c6832a8785083dc2a82b330a171340edc9e34622dd41f533595844387cbaab9b4814e12a01403a382e7db6b0f707e0f608eb45fce2c8e55a7c3b855f181349f38980834bb415ccdb53039eb20e16e94bd5e1acbaf10e9d86267858340bf187fadddcc7e01aa48e0da37ba7700ecc75624a82137f8b03b3aab62992497444a97b498e4252f1c4f769b2a31428de0a710edc36b6842e1a2a462b479e512384ba358c9a54d7d525e7cc06534ea40814555fd98ef5e77c8f120ef88851582c15ea94e768d53494017c100ec514359bcb50b88c61baba7a1db4de43220fe16cb119e7ad1d2040e4f9cebe5fbae64b0027f2e8271f82b4c1bc819a70c37e6a731ad76d616c740f23ead4b4283504b001aa7d719a07c1203f7bbdd6f30eaf3295e0007984432a5113d90f8e06eb753c37a470880b06da76ac4606c51c99722b2b422fe57ccbfdd0d7849b28e742ee769b33e8af596881ef98abd04b2b2f6fa3e86fa43176ece1029bd98135de357f732b5483a2072076dd5129dfcdff66805094f9c756fb77f34b9f0b629fda6982c44c13d5625e008251dd91c1487cbb528057bf4a08691e81edd1ce526ba9a80fce87143a2ed6fbe7b8bcfe8699ec1a9a64549909a1f1b46b8e2efd862ba5753f3cb23be2ebbfde33da35a428a44b38d629777cd199c8080a5d96d47cef2e39a1db5fb8117d871be534d23ca89c6041858c8983275dd09950c06f6c70d7911cc66e3ae753098982803061b6e513fa43cdd9db132cd9b28c556da9a409183c846e25a29e366e9540077efe92c8db6e71cc492f74e003d663c5cfc05600b0fd5c460bf01522c08bebb932b5c6d8b414bc769f2f3144b13f0d50da8dc2b3eccdab671297995ce0e10ad3c3a4e4997da3ad35a1566cd8e5fb7c1bda3e26f6ba16bbf2c49f57f984138f42e2df2e6693682516d7ff831cdb243067f0e0d7a8e37506e1e1ed0205e9e9bfb028aba339804b723aba5e5fa899b61648d893fb99b4b03000e4da40d68e5f451560907114b3c14728165c89d2f6ecf5ad11412b768c007059c20bc5b13bb043c1703e91b99151890e2b6c92b102efcffd1cb2f68d95cd5fe439eeba20287d4bdacd3134766aed9349a515e023a1074e2fb7855cb327784ee5cfdcc4255fcec45fa91f40d2270625be5f9213b593ed5c8a838e777bfb40a1a8d7c2231ab5be32c7345dce0ac435492432f5852bf0a49c01cef332acd1be098017a7e721cb0cac50b6ac496950ab4cce10263c4526e98eba3851a46d785c18e831c94d12393f2ae965b4a79fb25e5290ee323b1c5da640363a0fa4e6ce5c30e395fb42ec2adc8bbdbeaed4bc3d05fe582d1319e4e083dd4e0b924f4dc6d144e3392ef5fbf8143ec13f3cb2fab66435ade2f50ddb4fa9651ff57e15a0755a7290da14f998415052add090286d9d08b1675c18b5ce48c0a66df568f82bd77db11147403726746e7e16fee8b3dfcd7d2047a5c9e6ea1bd18da4002ed4e59de1b8d267ff3bae5b4f9d98bde9b16b5ee858d2e321c71645a703180a40d33e14b90a3071823c9321f9d3d4b626bb495a3eb1498eb4a9d48b6c0f30e780ce75119c36bb93430226d4c676085d204da665f579e6ded37d5c179dab6d557ce7c946406d24cfd9f3f7a4f8d6a2364336ad1b8424174ac2d79ebe2dc97343154d6a56be60290fe7b04d7993b49c9e1a9d8e1f1ae2f609ca80ac1b90231c8770b73ee93df05b4d29142f15d9f63b0923756de59830eba9efee1b2fc18db0d82af92839df7cbfd84a7feb625d46683e57c7b065efca3885f0b8608a0abdaa45796b55eed2c752a0e30e4dd0c5b2ce33b0049bf7b7d14b03c0696cedab880aba31118c2eda9edd2425cd0373dd40fd723a37643b0ea0794688ba91c2ac3ce84911d5ec563c47cfcd7ef7353216f42a2f4953754967f5b649b083eb4c151fa5f8e765461d999304c8c8d94b97e8f548d5be0032c8c592b8e21c07ba0750b41cb89bc47c9361d38829110d6f1ae8ef566e39f29ff19e2d39f600652d2da142864a38487457bde84d27142a8a2709af80262a6d581f94972efaafe5182de7e87716b933d87a5fada3542e01cb669831e338bc1171689178a791794b032f0416b74ecdc4346e483e3eec8ceccbfc40b03b8f0f7f00da9d9846c45bd77b4b5dceeb4110a5f6c7af90d603cd28d23b56f1a9612e6d43762211db892a3a92ea24c0176f868bdaedff0489b3924c2dcd74399013d512b3f0c1379e88f223372f313f1e105821cc61e5b5cfce7b748f6665b819bd6456ccd2f1abc8edb7a486e303b45e1fdc72f33b73842643dc8b423ce4363f94b1a6ed0d28409aa588148956d11710d711d9bbb4b312d5b48801d3050c0ad9b88b7c93b8f300221788b1d716071e9065edd596273ca24da8c527bf81bd35eb04a3178f93b1d93861bf025caf002d1e1357342a60a8366541017c33e0cd3c638cbedd7a5c8cf93f657615aac9cd1109354ad694a790be835f970c04ba4a0e732c9ecf827ce3457a97f157fda3a1070e5783ebc17beb766c480d40655aa6b824577d11f4f7d4ba593ab8e9b8ec1afaa261f4a55dc918fd3b784e2ae858dffc125189aa07929cdda83bc2fe87ac5ebb58c742c01cb04e01fc8b2664d62fa7fc9d46c528c67a79ad14f6cacf5e4982f4719f9bb1e2747e9df2915d4f5ddf02f60064f60793f42911bbe31996c0314f705ccc11dd1cbd06e8bf0fa7bf5f5fefe4688a6e33aa82eddd13582a5e723e8af1189d90ba5a461e93c6442bc58937c9161e201542627648a58371ee9b9ec506478527016406103705fa4f6c8cb929274f4181c50158e2aaa59f3287dcc2c2441b9b21f137fa283995ac73301cbb9f14a1bc370e08e7b32aa94f6ad71d5371dac5bbc547d230f5cc0a59abf11fa8877b03077205ad2fccc8706cdcc8438c33731dbdc0910ceddc958ab9228e3afe6d759d47fa259c011bc3ae7f2c949d8fa2f09a298d18f2889bc688883c4016a8043e9978fd6b4d2d1fd0a73ac217ebe64bc6021046742020765da7a669ca50f959e597fb77d9186cf457b34588fcd4ef2ff5f97bdabb20ed89b2949bc3ab4dbd94dc7b3354b41655e33ded4e9ee20c292ce59c5706282481c7b5ee7195f314eab5e271868aa52d04ffd60b0c5bdebe9aecd0fb4fcd0054fa7f09e1e85058b122ae8792a5f77982c2e88533cb60770d9b862a5ff48841d5e95248f70a4f2b0f4c25d0e31f36d20e0125c8e2d19f870acf13d15524bd6e3c38ddf8a77d8bdea5ec3af7d38ada2db9efeb1c0af52f3385a1a6ac3868a7b4a8cf72f73b6ea4f8e240182267ed4ca9b66cc7cd1006bf3a5795dd5efdb86f8d183c00410eb4a058f13b53c0bb7dae49033a5a058e97c5dd3181eace74105d7a049b309ce868c8cdeeb4fb54248e07e359746e7bc4dcd6a0debd9561c95fa27e07c91f79fe57f4f4d653dcfb22ffe438e0c722fc1032d1b8e3dd580238dd02db345abb3d6fb21ec01116cdca46475beac2b4f4643c943e1af3006456cae0c96b796db264e94e5cd013bf4953766d9c571a0f692daf8ba9a499a1b30c8629088edac0b3c562f3e7ce3f515ec3ad4bd1a1e10c77e22bc816af6624175729bba6438eac23cee0db805f495610fc32797df3fa161281ba262efb97b68652305dc141a32b4f5e71abf95cd89160052c1c94c5b9f57cce75f48983cc25774a7c643af0d8ec886a267ff97aa24413da33364a944ee638d114186b9197cacca5ec22bb64e0fb992a1343598cebc6c1c862ffe83d108e1afb1f1824fcb7b850387c8b334822c9b94c50c4c50c5f07aa69799be68712f0be81a63073243e7f62fdfa5a644ecced9ebd982ca5fc7244c3035ad3bf9ff5f738aa50b4ab555e15a3460f5cee332e8bcce03f877484ee22e49afc61c837c8f5c878ea26ed8d6692f65e27eb56419274fe31ecafb9429df30462689c33f13e42b44dbad2dc862d7746669a7eb4f61cf0ae06171a4491c665acea86de16c70ab23f20b420e44916fbeaa7146dbcaf3d01e512ccaeebc1bbd650f5865391d9fed123c28153eb7e63f2dcf1c7c86a543f1b71be30303a25e5070f944ce6f382fd2835b21845e4cc0215d03ba51726ec1a672d16bb86326c6cd346b8bc3f855ebc9d4779102623cca887550b0514ff33aa335d742970118e501ad9118add6e058bafcd0f2a66b8aa053f0b4fd182c1bb117938ac891b4d137e5e0e0e3a77b4a06350742eb77c80ad0a01188468ac3cfdbddd5b4e263c83784d7436578c3779889cf613cc8339d6f3cd7719ec34c24eff2624a83a566b998c9807a7ce62cd68c4c9f77aebddc8be439df72d3e4608f335955c84a02236c6dbc5fa7e8364874d736f80bd695eb36e213f23518546121678b3d30a9932fbfaaff51abd5ea760ed88cf78f7a3fa142c6cf049930fa3452abfe7e7022276ffb5f81a3d5b2838efef61b56e3ed8337316da8e3c1acf36118ff7bab80fe5296301df2019b5539cc797880489efa813125991153438464b4fa88c956ae00d1c6f3bebc33aca9625a0852ae1a3c0c4c5c85048c4349eeb78098699c5e219b249cbb558a85bbf6e6af7351fdc1d115bd913b88e3028d52f1dbf7527717fffe31805edcbb1a01f19836cb388e9a03d3fef0f2ab1580884e6837fb7af39422fc1ede8b063423a5442be0d7f3e31f3599cb793a9f0ab4a3bf6b8c347d93086d435296634f8d0015b5c945042ef9b15e4e47d5412fc0f48966e7b553ca1ffdf45db79a05d581291132e0ece8c1ac3308f95551b591928bdfcb53f24cb74a9929f7093bc02b84c137d953c3b6aaf96a579608e06b5611026453d464abde876e23e36aa6e8812b7f08851cf5fcc156311307dda8609c6c830000f2f0542e283448a86f010397ac5aaf372ace0d0e0b052feedf5c49ad142900f4bb0a6cda4210d5cabfacc974b74e0b4f3f91df179877fbd0d729aa22c52a8132e900693813f9dffd9260a4fd86d70c8ef08321e68f426e708740fe04397f3e33c02c719ef5ce027dd2bb5aa58152bb615dc6e250a3b4985851aaa10dcaba0a584bec771c72ca6022627314687553c0b77295f69a006da3ee4532f568575d4f1edeb17d9878bd4a21edeeeb639044adb4595687857b111f45114cda19ed4ffb05f5a4f17269553cbb01b0483cd30966046a5e5b8b7780da2990aa56b66aabd44","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"62f1fa162f282759e350539476c5813a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
