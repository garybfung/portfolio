<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
    </head>

    <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
          <div class="staticrypt-form">
              <div class="staticrypt-instructions">
                  <p class="staticrypt-title">Site is protected</p>
                  <p></p>
              </div>

              <hr class="staticrypt-hr">

              <form id="staticrypt-form" action="#" method="post">
                  <input id="staticrypt-password"
                        class="staticrypt-password"
                         type="password"
                         name="password"
                         placeholder="Enter password"
                         autofocus/>

                  <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                      <input id="staticrypt-remember"
                             type="checkbox"
                             name="remember"
                             checked/>
                      Remember me
                  </label>

                  <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
              </form>
          </div>

      </div>
    </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"abeb94c047068e0ae268dc10dac4eac73237dc3eb1888afdc667ae0da129bedffadd75ebf220007922e57a887810bd8919b20e0a10ff7da02da7d87dc37560eb22670c4dc29cfc39ef380d27ea54c95175cf577a3ac7bb0c8be1130fca0f6e8c34fe00d1080bc2cffc71f97e0cc7c7d008156e6f9642d200b7a3d61d87f796335cd4d20175dcd33300aad740f2b39f87fe24f66db3783a55bf1824e3a0a320f25369d70064096b551a82151256e8835c447cbb56a1ff4a63c03f10e82cf64f2350e2049a2cfb9127e54f1b6545b87ee8e01894822b9f085cf1383f2c62c0c923afb2d5251b0cd25fbf79f460a7fadf211354cd7d60ab0439d19108d6f1d87feb5ae2b068b01d7077cbfde04082c643e7d86263f9d0d26c1894e35d3a4ad118f5b4b6445ad05cf65fd0af98715815b8ac20bb634f30312b545bab0caf3bdb7080160a7c7cb5ce5060d912b274f45e13b7c2cfe68b8ba71bbba3f2a61c7e73eac8b13ee559b851d86f279881eb34ff069f7649d84cee1404e8f46000f84197d729f0d31cb9192a8977ca0363aa17d43d1dadcf83dde49d5e7c8d583eeface0796c0e42ee964f75af79700b86b8a77f5fb28b367b6d9716e0caa8f07cdf4ba47206c53770935345efd9f1e9e8ed7f74e4bb93b530b9285fd8ef3f0845358bf1dceb3a1e321425f0ae476048862d397d6aaf885f74d1e57af7c3cc3c9612fb08eed2add544c89741b6b536c3e3cf230c27c9d3bab06c1e351d50783782f38821d2feeb21863caa03d54d96b995c920abbce2fd46d7e68d72db329e137e5cd9b19cae5b6563344f851479c34159d6726e2f33d253e9b3c846eb57217268b6b83a38ec5acbbdb1bf91046234e15d6eb684f357a397d5fd529fda3ae1ee0b6eaf2d628c5c8d654fc3c6412d5c03b3c876de2ae56b025e534ac9e01f3fe73609d323dde0f63571f91ee135e604020f849b04db59c95763fd7d94e862a4ca0254414018a1b623b14ca5f38dbcf082b1248b9bfc4f9d22aef7b01c65cd7d86045fa62fee228211780c0fe0c9f3ddf43edc81ef59dddabadf6ce417ae2dac2a4e288d68299669424099df56e4352324dde9fcc93de860ec0874bcffc3509e4b171d19f2aa40d0547e6f53ca7de01081499050b4e4efe1976d25f28e0a9d3e39aa7ac6cb836c173cd5ea599333b14a1ab963da5a0a09e7e8d3d8051d26abdb2a1f1ed3e9d63065afcdb568807117d5007f60069edc56bfa3691e0275590a5425bcf6b124d51ab26a1671e29c7214dae0f09b675de19c1dbf88d010e021899c4453ddeca9b0ce766dcdecfc7699df37abb8ed26d67e43111ddc5f61e8b588c36187869e8e25b0a97db1b7514f5d0b1f0383d1bd791d161baa3d85938cd22f381bda402742cc0a4a64befd403dbf909a0c191de03e22363afde83b3755e80ea8963af925f14ce7f4dc8afb56b82db07f30b54bb9d629872af29bd6c5b6545b535a9c05c9a2b8a293392899916b7189edd27510e5177296bc1dee17768e224a07493f050ab5a87ed69bdb4716e1ff32e8ea782e5ac8db7db815fe8cd96d2836d932ee06bba3434ac5052ad24a8be3d73a27bb418e8fc0964a9ab68dce1370fe01a33a40591c950d185ca567b42d542601d304e672f5d874b58ef89dd08081172dbe74b3e0cb29a15a043942833b1614b1a444b98750a07bd53e43cac80880f0f2b1c6c0162685577cc44ff4ffb5795fe72d268d4c1bbadce59228269ddcf591dbfbfbd033551573e8dfbcd690f44ff9015b59b477247bda0f55a2793ebdbdaff71bd08ac2e80a0d4fab1d61a30d5c6da5419028f65c35a147af909f07a4b76ec8ac483b6cfedd1828d512d1d6d3f216ce8a84187a147833fe365343ab872a5185b70b304c9d3bc688a6d8a8dc8e0936bcf87e7adeb773de7a721e7967bd139c20beba9ec59172fa69c2095f73673c97768c2764ec21bd55c97d3cc3629c6121d19e47618c4c7339ac801c9f97c97b8c254a128ddd5264f81e8be82d334e0ac0d9911c0a015e09eeb7a100f2ae24b711b7692972454ee714939d27f79d5d62bf0b72063f934b4aa0b42de7278887e2d2945ef76c7ca125e85d938ead461f4335687f4c8aec68246264b00e52b181ffb418b2a0b40633847f4857e044a4bd22f637bfabc9285cb7e4169a22590ecc6133ad22795e389ab2877d81f6b80dd68eff1b96bec79e5ae81e493c271f31d5091fdd3db6d98b50029e551876ef74e3f8577da64ee530c0e3ef2c19ba4487051a1ac86af23ceb7a77b1f2f1de72f1a09440c9a93c88facf1eaa35e0d66dd0cf2e11b7444dea2df82af9b6c4d00bf955a48dd0f9cdaa154c51477979c13a45e2aa3568af2f5af3dfe2586702206e9c2a0d47895a913fa0ba0d05ccaf797fffa57d551cb24f74180daec1b231999720900f2989e411984de13b4ac7585ad9bdd75f5ad59f1b4be10a25cb6d76c0b1e8d4700b65ecaa1b93283d4f5c0cbcf41ff01fbc6a04542ddfe4c471d37e6ba5610954040b9543427c3215598f7f57d2dee52d8c27e7cfe618cd45ec3c58bd6093041f399ccf450f8187ca68ed1389574d78c41614677c32dc8feb7f59d79acc7bf21eb677c84fa99f1a95e7a0012dc121f47646f0be4504d480e62fc908a728809888fc1a85feca7e0e07df4441c63ef6746d7324f1f40485bf8f30ac293ed9729cf51fa4ccc9ef5ae2437c80124fb43ab0a48f59d86c139d461b53e040a762ecf7a7f70dc044a83d10500378c5100e71b4b8fccfa5f94f937eaa3ac9a8abfbf4c7ff9b2e96a7d9c416c34320c1de2db5b1a8c9c3e517269452d7ca3fc8cf05585d9eaec9e086beed35ee22eed56a1377d52f28b83d8a7d4ea89367e7829a84ec7a9309db641be028732dcfe6a80d33008d0fc15c704eca4e3729cc14e115b54334c1cf9a6c62612bcc6b8fd500e6e92563eea016d83141bb5b00be9853072345e8970248f393937ad46259478ba7b8ba306a23d4bd79d59a50bd001be8b726957937b50427d27aefbff4155e73032c08b6ab4ef9a672cb8ffd9632611499c4558e2dddf19eed7f8c077805d39e498a0f3a0191f462a1ce223adf42d0707385a205b105fbf323e39ad876975a11c11dbaf55b8a2d726253d3e9dde24fdbf91290b32b979f34c1ae48cc5ee311c5d212540e31930352f49e1fd64568a0834feede45aef17c7a6ba419d6813e000bdb2f61e30f7dcd66cd93a297ce51c62735abffd4a0d8e70322bbc05c59c9c526158807550cd904d1186e8b522f8f73ad798c247b1c8ae0ac346d51c48f4cba8d114a14da36d6e04b2b78379d1aeec4102bc712ae13ff705947c522c33db872cc6459a02ca45cca380b6585aca4907363b68e4f77c3de74bf853db67dbc9d3e6566c23fc8a6d0cfa5ea9b4918bea9bd1f43f3216956924067155bf1ba01aa0840e909a0b11da9bac6f00ff55027dd42ca4eeaa7eb1bd9c239e1291dd2e835cea2bd828974620b216519a6ddd05b2cab53a39ba9aefb64d78919aaa2b67a58a15bd43b96eed62fcdf00d0be09a6eb08927525ba2f940fe25bc6353edf625d70336aeb8c5836e0b819f8332af8aae49467e8dbc0fd2866e3f9ed781f861ade948501985d4901e9533a5b49efba3d46f42e2732e6d398e212e316071f4629e175d5911ea4c1e5f08687a10e7aa75a9ffa77b732dc3c82c50361ef6309fcc3261a5090a3eb90b3047a0031d0038122992e928a8eaad36d48ca1ab39e6c153d0628b3bd312d16734df238c78fe4a8ab114b83ca0c4ecc6651421662493fe244f2b367a13f93562496b3788070866cfd25b389944923587ba20c09aa2760ac47f469d50ecd2c2d343c92e0816c88cffb78c4cea5d8fcc5f755d5919147db36d5f71c16aca5d398329bcd8021eaaddcd080464d13ea657cb19d2ea5d853a2d78f983818fafd555296041fe6a0ac7c485d9a98e9838c71a7ab80bc6fc354b601fbc0fbba33c967930f46ed986ed7b5e87279046159d78e08f787512adb461672552f59391f2edb5847e73c33f9943c61f3a52b0129fde218fcf12481927630ea107409b1a986224213ea05edab85ad373507e2d578da037550f48ace62814b899cb592f3de40c3b8e8928a0208a249dc9c0aa746a9f0f799324bbd1cfabe0d1f8d673e33bbfb1b9717265a7a77f110c6c2d6e5021fb36b5605e5ac2ac8c694c43f00e3a2514889efa6d996334e41ebbaf52bdc9068280803df42e291bade94143b40f9f67b8248bfb748a57687d3e0f5d886dffd056e548a5f79beef5ce10425cea3a47cc51ccb0a5ab037bfef3bf93ec283e58e910caa85cb62b647d1984b8997b4e011cb9b896a63a58b01f53ad81bbdde78f8e550a12371078eaf5219bec523ed65e59b3421adffdc6a4f681c1225ccd1cd31b99e393f310fa269e739baf6387dd82df46d39a8c1a04e247b1e5bfc8dc5c2bf98e4b88b0d4d2759f8e74ca5e5cd716d6b8a7e64420fe219f2b4ac5dab0943e5f0b83b7667f9f3ea4fa0afafd6c6e55360edcb04751ae0c3c431589ba53f523b1b1cae7c36b3dcd1bc858b87fe787e868f9ad4e320a1402d014705f7c68bd572428fcae81699262ce0f34ea1a333639425e1df7e2b50df1c28a2189a8d0ad024ed06f34e34eeaf236c382009c9a1d0b7d1faf1a91a74f7ba3a9ed0feec9644fc5ab5b8a0c6204f0cfeb3840dd30213e2a629cf75267dc47bdd2296515c69c85f7460c3fc08fda9a70e5c4c567a4ed877e1a47be70de143527097b51e0ff4bf0c586946a2f83833efee87c3692b8616133304a9fab842905a09991840f129687e1fa572fa4f39577793edaa0d225f52bdf8dc96c2c9de466b2ae07d923045e7ba4f5c21ecac9266cdd7d86841035267d5e495bcc2914887d87f917e836e6dca08b4d302de6319442595ac5113d0b9a5eaae0cd6024dbbe81e9b89b6b1f657eb3480573c95123415ce53392372b3724edf41c8121dc565f56dc3205cd6348fa0320d18cd22154e64a41f8e02efe800bb9c3d440e2ae84d2948d113b101c05f31b2d1d69dbf2a148e5963ecdcf2aa75a0f5e6cd7c67a061c2794ea75d0f87e88b371bb4cbf1326813a704a595e1dd94dd1c62ec0652fa03394ccd7039eb3656ffdc5098a2d6015310efdb450c7be5bc115b9f705ba972d8c1520b06187ca9b643f68d3afbcbb458477158e2025ddeddf86dc6fb176706b6c6fdfd2116967bb6870608e41a3f8caaf11f142a3b424fcac5584c004e7421231813c286fb3d10b591d26f5e8f2d86d0eacc45a085f28b6d1fa8ffb96b0168b0500abb1ca2501681904a79b297c0f40229b5f4e56cef352dcb20c0277781de3529cddefac97ccdfefa0eb15e6cf99f8d434610b200f3ba661295441b919d998dd314d0a0296a6b5d5f9b837cc720c0d90ed0a447aa7ac67f1a39e42c122119872ae64c4e8c185a2cdc61e99f5bd3fd8e3880c4c3299ce64b704d160b278bab10546f365bc3755b5ee9a98e631e37fc4002eb07ff032f3a895e50f8e18b887d5290286dada2340bd77eed07170a8c76d0f25b415fa942814215410c19853018b34c20b3c8117fa430484bbdce6fe08b313224bd5229b4e586af573bdd00d730530509893a9afa373ffce6acb812b5aca7d1563c8f01be029422be96e92cf41f53fc390dc13d0eb84384e674129f032eb8a3373432969957d6453a4262c0e02bacb1d92e66136501baf6b81c9d6b0184e4ab673e5ee279f76b89492bbc15f63dbaf6b1b6d8e5e00e6a8188577db26669c49d83974db1086a8b597d0d91270cf4c8ae5ae31554a973009d7e2bab34a4703d7b0a6380a00bd22393a03cf75bc800dcdc0962387f9e2ae59100d851af64b7296b0b84bbbecfa55dc4ba70704c873fbbc6b8a0cc042ca6a8d6b3f011f76b8872254facfeae42c1a7a34e96782b42787e3e4b17402a0eb7ef729f9d38cfc39c620ab21f6f52e4a114a035a3848f1f5b18a38ddbdd96108749a674ec9458e77a1af027fc617269f3b5486449889c4bd8a7b5c84ae2e182e952b7f3078676540565df63cd5f986042d5067f84756c5068dd099c151ca912ae828410399783e1b3d6ea838316ec481131b2922949a407f84b1185feb37d078043b3c30d4b614c54fa6a5815831295d2005f31dd75e155282dd590aef7d9de66a95170329ee546ff5bea23ce5b760b61682f030b174d59b6a7021425587f82f44e3a40395db27a6de6807016255cb0c71678bae09f63dfcef2db9959f5993105b24f13b8bb6738e517b1f1b0d75e4050d51ba1dea8ec3209e25ce264ae066a9bd63763e2ba7ecb3e2e485e3338d4710c1c52872aabf644374be7db2313e551b3fb2d2e8785f6693b7b12d5801aaf4957463c6ef5c69677cfaa57c708f19c084bb235529deb1d858f5d6d880d839e02ca8042d3076614b7173ef191ff6ab7b54215fe527cb45ea54e3cad1b605091b7e2757f425c4b0b14bb14d265705e32e1e7b04c602f4c13bb97365621b54c3a3639efa7da8c05b412836381360e3acbb56676014f293089cfce8cb0e8d514cfff5b738de2b15a673acc70be7898b4b5d4e4850fb117990cdf2251a73f28fff9c5b5df01edfdc2b2ee7ab4b1e5d6d2724cad63b98b1a1a99beec39dd166b879541dcdce6d6b8e550c951275be192bb8b3c0267531712f2bc36b62174b49bca33689e51dd3e35bd00734b9ca277643d9f7070bb0c34dbf8b03e91f84b9fb583e18e0510cee370c1c11b9b800ae7c7631659f49461de63cad56d1a71c8f0a4476496c37ec00cb00883ee4cce17e65a06f70b59457bf30af63fa025126942953febbc5ba5c842b4b91687388f35dd84f339f9293fd0d83a78f65166b579d7430e143575a7d7e3df17e894133fbf4d2d0705c1134b396957578820735f791dc1d096ff9d26ecdf89e8bf9096ded0b8703ebda92de51a56d61006383dfb90925b12d77d29518a4be2c0116c2b5a075347f2b98710560d5363dcf4ebee5ba740c1508d3c76a7797c0fc4d7b312cd150a61c7ba155e1982e267bb1a6b7413478520d9bbde416d1f596baf9bb6d09407e28c0a8b5c7a026d47ccf2eafe5ee630409ba7fe95c8f7561748334f438223332dce078f2d1bcf13ab4cf06671d2828cfc7ed178e3b3a032f72f6c614abd1fde8e1ca3573379037b34c399ed3eb29e985d99bbc9244f78e94c0334ba02cd1b6b6695985e1aa284b178bce9adb7251a4fdcd1c09d8d452efa22b0f54f414b0356c47096528078a0ff7c4de8a8e203cd784dbb18fffa54bed43b068a03b2c120c9a8dbe6faa627f5593d117dd3d1cef3b46f7678b6f3912c3585c3b4ec157a9680f539d0400e6fcaa4f97b01d7d84ed56a639db1a2997b095af1653c77579b5d616fd06d41d349257228762d3492908fa7b5ab7e211ef1d382d4b89b551e7503c0fe1e107284ef3f7529fc20ad7f281a692c817c83fe868526f6211f8807ba7faf2f7e3388e5e1bbd3cdbec2a5945952b42b82a50094f23df95fe5e94e7af999c3b37e298437afa7423353a7f71f66bcf1704c14df3b73079765a443d280f01a3aee530786d402f267457944dd98736ea6b27699f9dfb92091d6a1056047f0e0d02c56f039dadfa7efbd4eed3bccf5a195bcb0c2b19b13c286b223ff4ea899e1abf354b80a250ee5b0759eb58a7641f22a9ca499e333b28b234d15a0f90d76e704540be308f58626949dcce5d7ff34788867c97642071415fc09112b126e41509e6a4bdd93e83b248a600e36cf7dc068a58ad638ab0c8058a7eefadaa3a2c65b645ed7296025f5ea0c1f86ecf5ea8d2ec9dd50825c2e75fb89f09f338f2e22157f7d203c9789d97f5873921c2e4f8b29d36956518f3f989f5474d058fbf1b1caf61b76793edc3afa1c011ec13b098c1dc4c416e3e293e0e98202e90d266937146c6142baaacc9fafe90e3defe8130dc2ce653665db2ca3beba998eb8c73920bfc69e5ea0fb0817b1184231b0cbb82c9d9e4737a687e35dd7d4be0964f2efd9d0d259b177d94ef70d85d7dbdeba4f204ecfd6770611f2238e91aa833ac65a091869ff6da3db7623687da9728027e3cb5af9fbdfe716c820711689cad46b4f11a974d061633b11733f0dfa05471b182a1c161a243733863b26849610f5152b8edf640090b780b81756a939d8f7d5583abbaa3aab770a023e853918f513b9ca54fb5d4487d4cfdcd811da5d0bbbfd6316a07cf01f86e77fd9f3156d928ea340286ea178075222a0f40ac2e8e87219f9a47cbc046060cce9e095399f187495bae3718e354576b1363a18272048bd7182fdb502757a8da0a7f972bfa36e23f24d6d5c033f83b4374b412ffe1d697cc35162be7f316521fe3ba56aab43a2b801ed07c20cfe2b014c5e18ae17682908d8c65b3196925bc14148fb761ea389d576c0c54d092ee2a98a549cc77ed316e5037abf9215b0ecd979d8d39c6a20933af2f9dcc82c5b8f87a0e9b0ae3cf579265215461bbafc5e96eac10f488ddeb6174388146840307595778cf07ec92e235ade2039988fe1c4cac161253a3d8692a0786f193bf593a3bcae1aaf86d1acaafcc4363f6d1245c502587162c2bf32b90c687e92c1ab020aad6b11dd4061fdbc4f167ca1d2d8e1bdf48caa69cf05281c6f7dd140060b8a56b66bcc490446c4e5e86af499c21f90b4058f23d095b3ead29dc72e639953cde40ed29533c2b3d2e102a0a69a0c9fc20520ee1180cfb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"2fdff11f64f85112d96b3ad7b3311f4f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
