<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />
        <link rel="icon" type="image/png" href="images/favicon.png">


        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
        </head>

        <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
          <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
          <div class="staticrypt-page">
              <div class="staticrypt-form">
                  <div class="staticrypt-instructions">
                      <p class="staticrypt-title">Site is protected</p>
                      <p></p>
                  </div>

                  <hr class="staticrypt-hr">

                  <form id="staticrypt-form" action="#" method="post">
                      <input id="staticrypt-password"
                            class="staticrypt-password"
                             type="password"
                             name="password"
                             placeholder="Enter password"
                             autofocus/>

                      <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                          <input id="staticrypt-remember"
                                 type="checkbox"
                                 name="remember"
                                 checked/>
                          Remember me
                      </label>

                      <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
                  </form>
              </div>

          </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f1e681986744ad25b8b6283f424110f6fff3e95f7f680332e3e54e1fdc9fbf3fda3fad78e1c5765599f4903fea0cefd65370b35caafd5643499df11d177598f99c307ac3d5f203ffbd31186d4ca740aca2d7c1d1727ecd8f3e3eeabe9089edf41cb57d02968f2e19c11421bbc5e97599a0db15e273505036ad164ac25e841395443e1b9c7e2022c3945fd329a04f7076465703eacc8cc02c0b8e1e9c942fa2d94a419c159680a4541649c10ab3b735c03c9683e3add2387c280102c1e67f70359c3dde3fa92a4653540e5309bf8ad90f592c3cdbf8fe00b598fbad63b4ae07e6bb8b2117ab894d61547c46f95ba3d89c30df7a8d689ef74772d3c4499fdb536682cd9122d87a1c4f2506d73f8516c3e96eace3b7e78239c5382e09406136eba6aa5cfab07b88fc0821cbe11c5ef65122e755c82a175d1a4bb0095a89a5eae6b296cf424daa85728f6914be0a4da688fba49c677a2e7911303286e10e7aa81911283e62eb649901c4b042f410c4d32ed3653caf88324f3bebadd03d7351b72e19a4cd904f60d9d133d8b5ef44b8ef64fc38f633f2b6d49583fe3f1762e74286455fd1baf5e342f6fa7a2ef37dfb397ade5a875923e124c2e4150b9737db1441039d2634d524230d4b188fde24c3c7ed16f84c5752570622d898128754225fab8c7b246aad5cd7e8a8b245204c20b6d009fb86da8e09a3a2618221b1709e721cd472747edfb3837d870e5d8c317edda4e146b7fb9b44fc18cbd966b4c5d86d08ce05b433550fc8ad371c744b16dcb5b3c66d40f24b6fdc8ba38be4665bcf5ff250fbcca579242c86289d3d60af4b63909ba33aab0cb61c38ddf07c4ba1fe75f228d46ecee62e33e650b301631a0f03dc130f401f3be0a01ddc529d0966a2100a14b5df19d7b0218883dd68e729ccd32c4561109d5997561db6ec4b2410573f50cf0961adc812378e117d58f5b81435f681a0d802b30e905e42e89fab27f6f24a2fe6e64ba85309eb8f9ba8cd6fbd286d395c11792486e6b91a4b7984b55ec284dac4aea114389a09306f45e3ea6e8247687a9699dbd6236f7414fbb596e8a754c27df01c0efa00abf39297e5ac72ecfdde511d6351970e81c80a4c78a84484dc5ec447b7460b2923bd0830302f59bb3a9cb07fd8e9eb6798c89d831b19134bbd38e6e9621b429aac8d4124cd0a479a83ced5c2faccca17b16bc174a19f2a31a50a92f73209c499e8eb020751c291304d593aa66d15bccd0cc82ac28b5f223ce57996a78ef550d0bb171fc8f493fc6909bcff6d7b435683334968ebf53cfc5c24ea6b8376e9bbf76d74742449d4bb959ba69c540c5a11a69c491e2341ffbf4320f1a5a42597745b0882799f320f2ea985ff8873254230f95ade9bc006bc456efa6c14a982618dd517e42de2b470b837e27af2f9a7c47eafa5d3ccd525a4d5bc8fd8384995cedbd1ad8f2f067b62b01336a40cc7bdf036d843258746db6444f9743cc13c832f5b466f9755719e2072a1c2c4cb4fad4438f70aad3e6a27e42a574f7307d194866dce26bae27130da7146c760cbcd7f912a065a3fd5f59157f6399b31af5aba3954a3649183a6cbb71efd3d5a15b2ed8f01599285d058d9473f2baa2fcde67422dc5b29d27b6f1b7af219c61e93e8e53c080661d6debd81a508bd78397e13e3b1b59aca19ee36748cd44d29e7221625791fff30ec1eab391b07bebbddfbe5c25358f297938294482ea5c08dd6f673d8e8fcb74f420abc9eed230cd331396d72dd50d9c5c46a4f518723f7acba2464495e1706fa44f9a8d15ac8da00dae44cff6c66ceb7272fc4b46bcbced6d6b0b60315dd30ed50889a09b83f3b8dda80550d01bf3e420aa2bad726ccc436c2fefd53ce02e5e5dba56b7d2b56e6559cc7023fb1ffec4b53c481dc42977635bf06c8b503a493c0410b3372deee6842826d6bcf2271790e79f68ab4bd4273c1d92926f273953c9ce7d3089039b1430d522b368fafa0690d126e085277eff1669c5691fa128b021bb80763cefc3ba88afb66b416d5901a6075abece4cf52f4ab16e109edcefa130da527df926d67d4d478ad019565caffcfe5dad0556e0b11302bc5b91414aa9a5a65e09ed342be79f724614e26bfbf63749437c992a8530b76bbd744562d24ff24df7bac412ece22f385a1a5b9d05f3fcccf69eb3d03d07e02a813a1e62d8d575c5884157c719c827cd7fb03e1a2c611c625b6488fb6b8f682ca1ea8f3627ac5f28a475df7176400a3b537c7162c0e8b7e96b1c449c0310ad31cfa1d2e5b07fc85e77da3ac18b7f7647f665d12885d5c296cc98c8778cfc302cf6c39649e6d97477f88356e9ed82e6f50becd161b84fe016dd8d98636acb677f30855e23f253219cad5a2445bcb4aca280ca05c78dce7adfc5938df95ba9caefbf9e20f4ceca3d05f2ebd2940c1f0a769464564bff0888e637c1683e632e3923b19b3524751ede9e90ecc7fd491f8ab8acba11be8f7dd2fd22d9e5dc40a40fa876ac1d852e54b17e79544577e5fee4bc74b748a58c4e0cb0d141933e1ff13f5bd637f9cf651030fb707307a1b183e2086cd262274679daf96741377da7c9d4a89e2067c658c3d560097dc86330b2a41c08784aa6618443e8e4918a509011fb661473e6427b2c536a6646682d22fbdf28ace6b191821754c5af50720821469866ec27bbee87924c96701297aba9b6c1a24d57088b5a9a305e327e359096d0b3b4824e25434264d854203a9fa22842393dea2cbc72f93cb78a1a24d988e6be13ab9fb9db9740e52345fe9b330ebc69f02f92f577a2ffc4e2736b2b1483749fc747b043039e6903ae1ae6e4de6c7d1c6abe211783300d6069868b62c2173b2e564bb8dcd49da44b95717d36651458a8dba7ea76120fd36af9b501904218f30042433db22b656aeb5ce2a547a047382e9df69a862566142172adeb953e0b5b1ac11fe9c7b81712bb1ff2b7f64ab6663a0b638a34a7ec58ce73ffef276d0d682f1345a91a282070554136f2a5a23aa34e3244c328dd17d77e66f1df22a1ca81c41306523a674c96d008f4828eb236159d931dba2f5f35078fe41de5c3efc361ca2224a2bc4e02dfc9dbd7d20fe21f929c84b8faa89304e875d131d9ce7ca8f7185cae277846a812939f1f186af66519a4ce6ebbf9c6d9ecc0a460b543f4907ace925df47c1c7d98664f07e3cf5fa2fe2b4d354f2305112ae37e59c2b899af66eb1ae64455f8df732d07a37a1fb1d8638ec14ffcc4c8fd88dc6b33defde8f2139e1e9601e40cf67c20422e94fb8b55d7698089c2825392a45f9a387834e7a06c86909237ed4aafe58b40dac7cd6f30a02f0253067014e5195a0f208a65fd3eea7822dcb9561893a3b28e1ed22d9fe1b418af4f50571bd02a67e25e9f899dd48ec25d85e55a29c5913582b371bfdc31fc5033d5edffabb46af64ec24482ec0c9d56316db1a54c8fa08bbeb704c8a545199ef60328f60cad261c07355434e3e70663f33759cbafefad0a45693ab9c20335533ef46d1bd007f06873e80538986d0f46191f7c9a22e49e3de4b58919285828b0b67aff6c22c9cc3c9c7eef6b1652698772de3401be891c6b0cddc251a866c76cd47a6f6fbc6fd09d962065ece5503e58b29b9c7ca32eacef30d10dc1984897406d8d69e1713189a56ce05452bfc4a942cccbca0ed372e42910d25baa0924a053cf4714de1c9dce3f4524235d5f6709a27fb848c763bc144798b4ec56822029853b796f171168a1c5fcdd3f099e2a724ef1bec772d2d73631ff7bcda9cb6f100aff8d31aaeb4729bbb9ef114638eaad390abede5487b8a7803e26f5b2f26adda34366eac2116d384df417d6f5503219bce68b1da111219565edab1a5b872d69389cb91c7b4f2c3607bdd5315048d983a04f92985bbb126055cf4825ec8603b7c35fbfb38c59f5058eb2e956828965ae044a7ba48aa4c68867964344c959612ddaf265f49645e5d0d1e113bf55ee3f00083a089b293e4331af6d30eebdac649541d36490156db34f61cd21a711bdf3266549afb0b1975714bd2343b876a168e05baed2569c5838176ae429f624538acbaf7bd6601a6aaf5ba9f85ff19eb1df854f9f44c274db313af1542cfbf9c7ba313dad654ee6667d91f73826ac1a0aeeba82124660456603d492468e478dda64c9a14ce6851ee3ed0613679594c7e206aa056a6d349740c5cbda6271caa4dfdbde449c5cb2f6e36f435e8c74bab8a64d0fedf353c7034e4ba02750f680402d760ac60422ed74593b77674a284f82e18747cde0ee296e3c018ff1efdd7438920b6e68ea9162857c5635ed4f661e249ac9e4e263ecc5159db4aa3470086149449105e04dbb93ae50db5f4309ae534f322ea241d52fcaa2917cc2983ba09fb9b762d71493e758e99ac5f9d3333da6ff24d5202671b238d9286592ad38d7a9e994c4a81a5fe63cd8bbc77e074663193cbe7073eb852b893b21c33debb6cf978588e877c9edadd7aeb6ef8a89a3906ea90afb46167ff42d71c21421e9ad033753104f5a5aa7f27c11e2a801d4eabb5e8c80a847d9a56fd4ad707d6203b8eb7a6dcc4fe9371560d029c263ff712dd16610ac25c4e6813b67e231a59fde666819274916dfc16cd2e4f3d99ab39334c5a7f110bcf18ae489979014f78f3ff96c2468c7f059bc79e142532736aa7cb4d5e85d241021ef2c42215ada004c79db76cbcac33e024327943e746d58e5f76f607965022fbbdbe70de3da2c3f0d70ef121872905917ea8ec28731d49a768c6d612ab5b3e7aef65f0c4e38d25319f4f4cb4f6adb5a56ec0445f20af81553056050b7f7a9d33ed6558a9cf745ca5fddbc974b4c9249827800cf737339f934904ce131ac6d5a109cdc2ab4ac8b1fac7c937cec7c30149991f8a8ef7d9eaf3fa865f0299e791a34ae11d218ce1cb7b2303bdbc9ec794d938dbd25e2271433037e71e77f5d083c06914d5947291ee8895eb4f9c754b24472f57387e2a715e5ed6610656200ec5b8a9ee623e4c2e7f84641a3acc22a27c57e063469f52c931e54e99d8da6b38c8e7870555aaa32fd40cf439514aec89df0196973c49e1956700430f3d0316ae720d76573ed5ce8fee742841544d28412f6657af2227fe7b09df3bbe20c820398ddb2f5b69ab9c02a3a30de95b992d8730c330933a7ed2ea44250a24b78199421366dd30ce76449a833d4798a6400c096606d105e61669e4d6cde8e377343b91f98be228f585a0c575f7ca2d2470d47178375c706e9668846aca0b30a8d1b327f2eb675adbc736ce9cd3f059c8c59a13724d526838d5f039131b7180e71866c93ad6687a3e3534b6caea785e78f19cc41d63f711e88150a88dbccd510c20add5bae753184a9a09193912410f98682b157583c7c55886b8c6b420cdd93af6c868e6679667dac8d260beae5b1aac8aa08b16ee04d6bd9034454b7c6b56959d63953544d9fe552d26a5cd14e366974eac86a2957adf6d71b04cc37790e6bd1fabc8fe9abd663510f0e8ba0aec8f25b1343ff10cb76091bc5abb3768b430a5ee1cfe03e3b8c6044130f44dfbfea71a508f26b89cb24caaf7d6a0147af20f5c6a8ce8a7ca4d750753bb79dc8d14757001cd58d1228e6cd0b4b81c26a82be6d2471466e34efb177a73cb5f64105bd440e4f19a666e52a926f000c3d0d5c3801be988b2d7e086ef759bec262790816004259eae63089a3b3997ebb71ac2ada066bf4d6fc8da4a0beb62e1c149001f82b3022e541f67ea60219dfa50b2b583a597aeb5b102910d1d2e796776a2917984eac7331372984ce8679397a9e9430ac4eacd94a26cbf7f90cc46d2a5e6f41e8aacabab978404ecb5a15ac2712a27758b203f5c21aa4f38eace9dd75c2c6a250657b7dca7160d392fc9fc1be4fd6cbf94fdc0df60a9689ff7a9b61d2bc0596c65f1e1c4b4e10d7dbe7588d80f9d5c2866b1e534e9fe7b4d34b2e0fdaa6e8a5b79a97eb16d357e3d27b40e80767dc5f7b6e0af0b955c13ae05f082f0bc26a957870d2afd248e555434a2c77aaec2d910170cc28a05b0a3cac599e6569101235b2b32eab70c7b13f94b76522b3cfb7c3f2d6c034d46037b8189ad5d728fc0d27ed446951d55cd05af5c5e4f46196afe868711f1912bff0ad7cf9b80a2798041a65429b076e90940324263184ff4672eddcf4eea304600b7f9505ffeb7c1132e3d1bdf6fb7cb99650d6fc280ae2b9a09458746ba747cdb3819bce3cd917a7da6da95e5e2a63b9eef17f406c9ce9603262eff2aec341e5dec2dfbeef5867778e3aeedfff8e50e30888b3664a0e7ba798dcf6487511287117f12e81b8f90b48b391179d0cf605bf08279b782aad5cba7b7ca1e0e7e45e6d04a3c364cc62cc2ce0b676cfccf8b67fcf6e9780e8c512827c564dca938c4dd9056ff20d3e254ccbd328f322781f54526733bf93ab9d2cdb480af43dc6efa46733bae22e23c0901660a655b53069d12972b74ed02e58e070ff5dbc99248bc207fb3a4baaa6873c2ca902ac3ad10efd90ac231777947ee4221f0b707534a7b9e7a8f907b874b3a8348e653ec5dd772cf338513267b8c9bc1e8f680f30e6932bfdfd07fc14174b231dba66f530e4483e5146851048b587a014f2679209136be9e896119e7f66e363f80a99ec14d73f4a02b3250cb27265522436ab56ef8db8c77030fe90e4d3eee82f226e61d263ea3a49d761a280fe325d741adfc89f5ab06022b66e17ce2ab2756216bb1aca64ba1a084f633ce0e039fb3ba822d5edeebebc17a60a6fa60599c795507dc8cbf941ef066f04b2d34bb7201511fe1f280a09d2cbe5956a61e21e944460969935689db6865226cd019cb13f3ca682d21ed182cdc5570562218ed6a7d99386329b36612cece6d31ee1bf0f73e3e3c9de6213894bb303c5692dd8de907d0a39529a593fa456b8f5fa6e215d392911344123732321cbc11485f09cedb829e78b8e6a84e483f9d33b668223cbab45123e315c18c78c105be6194d4a6630ebe738e68bbbf9b3c49175c8ee7a0eda0fde64e1adb6e08a1b1640aa1cbeb8d1f763f0a48389348e042f388e0db670d18e75080718317ebfc1b278ce433160dd54aae7539f63209cee5416affb4cea4c323a7f7674dd2bf1c4c3d2a33caf9371072f31c058319270a54b6ac9e7a52794c1fc88997ea3ec3595502e80c4d7ba2bb30aa485bb8522d440783a74e173741d95dfde37596a70eacd381d330a05b3ff651770c4c5e96a38861f4422fd672bc0879e01fd8ccb658dcfd465e0e3ba94df69dcc58608ee00d2a8dd0d3967c4e9f0b03f23f70dc5c151268c5307b803938cc083a4a47966df658e0822ab85cd1299dbcc9dcd3509444e94d6ee7629aa1b3310a02184b48d5a9f58de9946a55abfed269c445e04c3fd922796998a99190efd3b80cce0c3958c71d3ba137ce08edf6d646fc23e7545e6716115e475429f40d858d555985307608636df8140c379b8eeb515ccdb6ccf4af16d427173d63a8c65b11456e1eea6c39f05ecfe3354a08de40e485eda88b304d0b6fd6fd6758cf0684c258fa95d89abef5cccfd1b49ef1018705ec8172778843de7eca4e781fbee736268f912f778d08d6bd343978a6ce704b40b4f9cbee59b9a109da9486e88a85b4b21774b6db30455240b28a31165327df9808934a8d9a5643dac90ba932c061fcd0e50f73f5bc3b702bdc830944eadcbb41df4903d173e41c86c9b34359a8c911bf0c6e5b151470c0b13119ab63e341f90c2e145894cf5e10c2a9f74fc29abb11f476a71cada8aac28966c101aed6bad4bbf062e65631e295d293c1295bf14282b50c4a99562c14c3ec6f2068c7b49e2092ad1e7c2b3c7b10fdc666deaa537e7569016da69ea58f50c21bdb208236924ad489c03c281e77fe079c9d29b946ac33ae300a49536e305f35a6a29ae59b3f862b378f82269d5df203652675acb2e3b3b7d5bb9cd93741f9c1d5a6b67c8cce8fe2865dcef666e6182559064645b67f8a9d771639b178a54a5d086bf3956e777499ccca286cc511fa82986f4ffadd8d0bff20d9ddcb4861f3dbd2f33af4f5b82af1a53981e5e8ef4b8092b4230e0a469b1a73997fdd4506ead0e045666486ee7fa103744a113ac35f0b2b8c680e785060e47e02c838c81000ed408debce48c4f0c30d595c3e9ad6833142a46baaca50ebf95c59e2ae620e139f14b5f99a773cb55bc968af5755e94b72f90fd453669b09c220aea09dc76c277196939f0b267fa684affddad895672e5b444f5c1e1ae2085becc9568a185f34bd6bb5b8535d8cbb5732a18593458da419cb7e968af1f5a94f5a1834f567f23031998f97126e8ea7d4b2f5c89690afd284bf854737cac96bcf95197186aa2ae526634a255928ded1d152d44704ca847847aee9f7e731a3131f106d3f2ed4678f5a6bb004bd2336c219fe5131644596ae8e5e71977cef4b0424d8e92b223168497a6b9f1cd5fbb2de99f8b9920b8c2a4724de71f2f6d8f5df06b2df7659b47ad9df945fbf7b38bf5e96fc9d69a37e5b64aee6ec3fc383df02f904d8784cb0f182c85322a318e34e717cb88bb3e3a4056a6640ee38c8e783fe07e8c52dd53c8dd1a1f465bff5e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5ee5fd513385e944601357ebcd5f85dc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
