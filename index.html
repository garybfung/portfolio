<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
    </head>

    <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
          <div class="staticrypt-form">
              <div class="staticrypt-instructions">
                  <p class="staticrypt-title">Site is protected</p>
                  <p></p>
              </div>

              <hr class="staticrypt-hr">

              <form id="staticrypt-form" action="#" method="post">
                  <input id="staticrypt-password"
                        class="staticrypt-password"
                         type="password"
                         name="password"
                         placeholder="Enter password"
                         autofocus/>

                  <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                      <input id="staticrypt-remember"
                             type="checkbox"
                             name="remember"
                             checked/>
                      Remember me
                  </label>

                  <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
              </form>
          </div>

      </div>
    </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"31801975abaa40ab731512b6849516e4d33daee08bd039a46183804c316058b5c6d855dfc476221779799c4e48c46039422508916371be8fa83ede3da62629cd87237b513d1c783eb45483b2e9b816b8333017d8b48b062a08608611d053f61f79bde836ac20e59ee16cfb5998f714b70ad1c9f0727d21fc1ff6f825ed65db77bbe247c64046458534699547e42bf30e206618aa481f0034751e429690053bf54cc526d0eef0245a0e1d009a65c4840454153e1942f3f89f39bc9af13dfdb84bbafa7b3bfc728bdf9b3a5459fbb1cbcca14f4b3130f4d3316369ba1eb5fea25bfbead12694d0e22803215b5186d4efb377b7ea2363cb2842ed45c3ccdcf95dd8665dd5591fde897e6535a2b3e503223e9b93224aec7e01b2731df6696e0a2d8f4bf0eb8caf24177c5c18570ca32c316f7a3fe8a637be536d1f181ac4120b1209889163afc1cbf614b79bf5d4f2bcaa61e2db127763313f6577ca30998fb4b8df66146223c2815da3ff9c18a94630b40221729098e1a5ef3e9eb7a015e26b3474320f0ccdbe23fcb591d086c3e7a1db1370723a6f63f23cd5884df840c6be642bf7c5d82e455b281eca96ff45fea43701e3aaa935e9112e85784896ac98e9b4d99365c7f1c5caed4980f633f2e2e2725ede90ca43b36a3fe8e193d881201c4e5a0822aa8a5ce895529c2c5782f4f15a0455de1917b2a00f0dee3f0d885557bad4f45d47820948980985cfb5e23744037a139e48659995755dc121d5689a91e662fe555ac04b2112d5c255f08f50530b6f0130a7b12535eb740c15b2d4e7e8eb336c898cedab1ec75db9a9c1e763eee8c558a4b3d085e4d23385bfd177651e5fe745ee9aec633905ee36ce17f5ab053c952d23b005ce3f0ba52d0780db6599b51f91532280a0fc4c915fe38e130bb84cfcc40add690e41561f7faa1f2ecab8a80f9761fa6226eebe52caef13a20b3efda22ed3306973ca529ff5944bc47793626a8c16816c80a7a0b915bcdafff1a0272f744db3955be03a117f153a98736a3d00fede2772f0994f4d24820686fe806ced986f973fcea2e6704c770ee8faac42b7cfdf51128688f390bc28afa390367510a1773f51bd7fd37df8274839d5d2c7d8c0eecfcc3389534ab2b8d5b1d108eb5964b755d091f2f1ca8ac8ca2d7a4bf665e13693c84e1396e1a72b600b5beea9cc4ecbdc3d5907864dc32be766c817f7d908a421553e7a9a6328e42ddc6607e3b60644558f06a138c763e89fa1a116fcbc24e94c592df5161cfff9cd187e2b008caeff75300f83e2b2e947baaf7c78bd4fbc81a1118625c834753197b29b9dd805c54fbd47bee31c2d89b9d58a9ade227907c6fd44f203fff7f0a5edb0d4bf787071d8b68b9ebe68a39a13444e6f5a491fba34e48299b45612e627093062ec9004413b452e96caeb20f6ce6e591a352a1f94eaa49d8fcd1eed45025de55395f5943fb6b35d7a3fd45a7e79f8bf673c55fa57b08e36f73a7b6cfb28f723c92140439a4eaf23bc82879f4431a1dbd471b337b994dfbcaecf7e5cf57b225969a1540e43c49cf64eb136c1ad34c3e540831eb538bb7159ad1331727fa260b8711367aab0597ebc4b6b771edde7b0adc4f77bbdd4df62b6067648a667ca388f5330f65982e46d9051a1a79bb112dc6a7ea9c55ee330d55e4224e8abf4d3c1068c48612e3ce7e2a33225151f10a83abad92eee269fe759b752d1b38beebcaa3280cef0bddaf8661cdbca0e5d66c6ab9b020f5114f950761a937c0f84cc2864c6e1c5a574cc3bd73753ef982cb5beca1500b169cc94a4f8c0bac39c0b0c12478e32ddae6ed717dc9e9c594f0a77e9bba29b24925203562aed66a2491fcf3185e5d6e1b5e3130d1bab1e9eca48a3a80f574e0999f49403601bffef9db3eceed072d4d3aea71ba6f2e91e039b1299c65ff010dbceed1ef638d51eefbefe81b4e9515c24405a9d838de5a16ebb808b42921cc0a6d1b4fb39ba84d78a5cc0466ce628f3c588038c4bde23758f098b42dea890b2a29475f637161a4da9f1537bc6d0be178493df0d6a49d132d60f450a51d277ee3cc80971dc7655a23e29eb4646a7e5a56e52fb197003d0de85a569731f8d1373185b0b5d833b5522e32f9d20397d0fe6c228798a9de56f9a86d20005fdb2af1441a0eab2d0bd6b595ea795192e84618edaad7a9dc6bd41258c16af3df8e55b342260de3c99ac9ca6fc9ebd985c88f62dc3cedb4a18d8a3b53b71b89f3af36af6a42f1b9a5a03ee5f994c1fdb29214a4914fce88fddd345743a635f2ed07d0cdd948d8ff6570b7f5aa39a678a6724250e267051fc01857f2971086d3d30ecc6b2f6fb65ca140d7df4622ec97d2643896efa08409b0fe57f73c132a683de57d9d3a2cfcb4aac62ed127c3ee58830b4bd58e3bc734371cce40c56d1f4bb6b0fd8ec73b4afae7425df22bc7243fd1a5f9304f20af628a9f60febaa0e158fc8f65fa132b02906dba17816592a5842602d212704616e3fd32a459a012131466808024c97572ed9cb07eacf4b62d1cb94379817e9445374d6984fcfbb4f760d08bf375776336fbfd8f2c3b686c0fd888f7785a2ebc72119e579f786cd00d8fe6ed63054f1e6c2f66ca36e744a99df2edea53b609735be6239f7aa375e4be03e228c8fe6b68cf6e9c3abb87f7b3ef8d779eb31139459f6f2df1267e340ca0d13511d922a87ab462aa3ce99ffa12c2b4f2529ddd71227bd8e662896c29f17b84643a904ff81b9b9380a9ee9dfb3699fdd622e4dc087ee48cc771636397c489de5b34c72612e377ffae09753541c4beddec54b6999a9f28d49a73bd520d36cfe5343f5a9098e4dbdc3bcecdd7ae22a736e963e1f099fa5fb2a17485d8cf16e0ce589ce9b46a6ddb96671b84342785d00997d0b6e3de63e13d2ccd6cab2bce81222dc6906781738a98d4cc49815c8f47b6a9898f4c376b6e3908f584bef1f9bd75a9529cb934204c5ba908765548a0bc4483db9c057412e8b6770301c71a93e0d8d72a64605409e8f7f66b77ec9a473e3233ea7cdb669d7fb7b3ad171a39ddf46b30aae099c4fc5900775c6ecc27f6d3d9d84213b8798a9141d39d30ac49e8195f4e8b05d117819373b9931ca87271f0c2f8c2e656037ee869c1dda4643402946ddcd5d1ea211db26cf5c089ca2164d03cc2c0308d0e5ae0b7785adb4250ed43e09446e1432ca6695db34426653d5030180edcd851debdebbeb61c9388edba365387debacb06ed0631331e520d9a4a565bf1b7dcfde65816df9bdd38bddeb5b72c06cbba0fbe4bbf82291ea36f9972ec7f16d83cc1eae3cf70bd5a089b2e3dca781914cb50bc72289b7b38f8b8bba153b3370e33f011e7d89d8e1097f0b50453a3029a04415cb05ecb0f549ca0ffdcdf8475582d3e0154344fe51d7136475fe629e9e34ce6104b95167a6e8be3af553e4c4b8dcde7af10b5dd22450118ae0f7ca2345168da8be832dec15354769b078a9502c171e6bfc5f3a2da452bd726763cbf22341128116ef023a3bf89b04eaf0f08c55279665d674f953fb52809fa301e6655218048badaa783e90023cf71f4b7c97b6114a1f24cba397bc8047a09df1084a08d7800f5592e1a52ecf8456cdaf40837a8e9de060a262a99cf2430de18b8f9a316890dd20cf40cf531a003f11859e58a605070420703ad3021b6e9b9acb6a39e41c41f8b2e346c3a4af63c19fc0e4398d9ec31567200ec78ab710332397795f5f6c9a937db738af78c180e8cb8e12c17fc16b27141959de56c7049005772ad00f12d8e90a641bf64d62fdf453f90e3569256383af497686b9a2b7022e8782ea1c84807c2d359fb09f6d23e4ffae669cccc76c81b1d1dfaaa7b0015369044d78ad64a42e9c09ec9a7ba7e7a7de80ff5b3dbd8c14f88f686c8e8154c8da81bcc7151e95fb94a540d3c002d173b3dd2b16bf0c44b4f210fff418f5dd50dbae2785e91f948f74f88875a4f1198362116e5c7df6fc97f8d958b57ab98c15950d2e1ddfbb1c1b8e379cff16cd2252a5c995028c79cbf9b36b35302fee276abdd3f92e86a693fa116fb0357a4136f4e666a52794ce3a74ba780f7a59422948cdfa9dbdd6bcd6613622f3a0bfa9443812a57ecf207ef0609909eff4385f5e870d90cd4ce584a4af1743c58e54e0498d98445730e81853a86d937ca378297e49de8af2f4208af666b557aee9dce39e243d456b640d3c236c8f47e02ffcdcadf98b41c80beecf78175ff88e7f91d2b2adff2fe31c0aafd9bb827d69c9159e2105346ba8113832e6b62f28379c622371bdedd0130b0c205aa29b7df17f71fae2a85b2df11db4aed7164da4ce4f425569db05ee96ae8c776fa8abb0e1ad9fdfdeba7dbf41ae6bff5a4c7977cf73dd3de3c2b9220603b2baab2138405387fcf87cf4aa3a9ce658b7f06169419061ff2080ca0861dad6bd25f333b8d1b34c0afd11ed1f54615166f15ff877bead895c725cec03cec189b0cbe3be9162fdd453e1ba08ead66f821367104ae4b70f6276e3b9594c1f811afbf1c2c44870c61654cae1d90306d8c6acf42be5b02614ae5095c14a70fede66609f08b7f57c1b70e2ebaf29eb0b14708472f4ae9c1ceb3014e0123385f07a0d0256ad4cc6b7155ae63f0846644c32f2b05eed84e935994ee1b22dbdec259a122345c37a7e502d2200aa95b28581e9d9212f6fe21e74e688deea6e7a9ec92973a6522c9e98dfcdbfe4d4591308de65f9cf6de11d0e44e94a9f096bdc989ecab30338fb89a5ed7b69956239bbb0d9fcde3891f04fb7d99ef20601e133a08567d91eb3add43db08c5745f3d6dd4102d62f8f2ae34bcedb9b3fa531b6a2486bf8d1c66d246427e6964456ee4b5fcc34998c0302464d1de0ae471c35b0ae7e823a7be70b40e6cf9c262cd1a2549faafb0b0fec2121b44c0df123ca0823b5f1c523dfc621abace5640f92a804ccc7bebb1ab051ce8b1b94deabaa2607a55cc775a5d96aae5ca9a537fbe740204d57b1fe8669c6e34b0e1f9e2196c11657d1bd9a9e59be4575d0361623daf22e9c30ad71775c875ef533c5ebf009c893ae825c18b08655d56dcc005dcd0b0035c1b8bf6e123c48fa180a91b8af122ba69abf4b2fd375c8b49f37c5a5ae1391fc3b053ba1d6996d8be0432b85807252afb9c229930a610f7b8d07e418cb8eb2109f96434d9d59fb93ec16c5879166021b177f2c4fa7daa55c3c68fa61b1651da2d605dfd52a792769586e9463e4b808d55f83298e232769925b39512e9682a31e7e0734e14e4c52efaf0af1c65d5900f9ac9cd07e0c55c974cbcea10cdeeb1442084f834ded5754f4c2a81bc419a2c39caaddbf3b571d4736ef6b333b03e05495fea87c47536987031c3519f0666c7a17ef4724bbd8647753668b173a9bb1a338058a8d2a3170785efb08e6a9866443886fe614bc1470720f7f484a6d3cc3d0e2769bedf22585328326c40aa2b493ab80b4afc2e47f4eebe57fa63767a8c9bbe3b1fd52a25e9af31d450ad44b03c5cfe4dfa4fa27739ecd67fac764f49040393693bd04d613822c427e2fcca2b1f0d38241f44e6222b871e23341003b6c928326a28055081c77c83c9810f8050a46e1334745c70874a88348bfd9a9526c6eb64c7314fafb9c291816c89b5c1c023ef938244463e8a86ad8a2f54d449e5879995191b50ee270d2f9ad7d3eeb3a4d706b31be1aba6c305a375e4fef4e4276bbe0d202f53d01b2ed49a4c1fdddf245d50573ed95aee5b4953e7126d0d3edf0d98d89ee874cd081ec6db176dc3f2b6b27d4093d19e16d6577b7e933f14e5de582548acdd014e060c04c59b07c3895022eb95c5729572556af2ea9dfc5befa946f015d4a3046b03bc6b4a6b8c00c70e36bd35c7ffdeb44b7505d4d4ed4a1a8b40b0452ec8244deedc9598e438e15b02d7b472dee3daa2fff99dc178d791f321743019c0e6d2b0637a48197bdb3b60bc1c955f9f152c9cb9d51dbc8c08f65a15fa0732e337746b20a3e536c07a36d3489d2bb7f8fc914bc3c11f89ba4e3a16af4a3e3f222c938b1f882ded8f24090e6522b21a8e383a5bd41b388dc5355e371096d963312a73c524431eb65c54fcd45ea40aa914c9ed172b98fc9ad56da94c0a8dc499d5a716b2502071c78338ebf7e6647a93c09508f01dbf7be73de17b9c1950683305e5d2c9b0c8dac9277831cbb14beffba456008971b3ae93cbf68e89ef39c169f7e8c5ab939b5bcb0ab7120bae43ff5c01b7ff670afe70adb102f6f16de2edc74a1a781d1943b7d4b7a81708c3a8608efaff77f435fb4ec1073bd78d763cc2fd6219a092b0c1b9a12ae9392440bc6b22011b3ead2da8fa1c8a7d6458357ad44ee052b9fcfe68c10481920ad7ee4089b54cc94a69d65bb64557d1132b2ed94acaa46455988df510524c3dde96461a090cdf4d579d4e5e0640d5a0c7a5a253cf9dca643645dc036691e8f354adb60001138d75ed563942978504caf8364e851682fc67cce17bd22c88eca036f857c342d4a46ba28607aa9c898e358dcfc08631ba268764f8367075690432991662554961d7cd6ebc1b8febfe6114f8c6a7668a6a060dab43d8001d3745483ac27db142f6c225073755a3d9b6399a0d19bdd21b487a0b547440fabdfc0dac9b10abc0372176510584b3e6658482d2e37f8ed3ae382d33b15979958f7f26568569e6cda1313466eca0f142ebd55ba1f5cb36d6defbff6c1d6baa07349b763d4b02382878dfd2cd09569aa8308491d0020e9e81fbdb87936a833ad7ad6a94e1f95668257a3218b8b15de32e44a40a0488ab1f029e8a729c62ed456368e699f6e69ba8e5dae11f7645246ed0d9e9dee33e4573413920497b5d6103a057b1ee25e7e83e5611efc0c42f182ad5a5414a70a37bc3b2af6fee648c8f1e932dd34e933f9d129343206e4339e83a3ecf80c0bc1e7b08b1e6d4c94acaef2018e1cb7399d37c96852c022859d609d79ec8d727ae41f1e5701a7a1e96e07b73b36572cb88996d4842af01e6acb8ef50d6211a31210ee3249fbce06bda93a02fa8fa4574e49bc54b796c231323c5aaed7ffccdc43bf676e97dd9d38e3622e445e766bd93404af87a4f4bc8b2a8e8646928bd12c51fd30893fbe9cd9154f43ea444381eb424235d5a492a0076544223d5a97fe335a04ab18c2e69393112c18a79d0c11d07a2ded3a4d65f39167241c2dbe39a1ffabf377995f25eed9297e93b63bda0d5d793736e78ed2bd83a1b3d6cc7cb0b897d48ad090f472157e6a1a5bdace3b3b8ed410361a98b03b7b8d0d58ed4f2782f0b654d62e69953f0440714bd31b30208cd5164896dd6e1e5ea4c81f73cf297cd85219a704d4e2b340917110e9d871ff7a0efb781d1a5532add255f4e7523aaa2d1624d5c4a5b0878f1753d6fa2621d076729e022d195bac50a2bc5565272a9130993da975390717ae1e3797c70bed9ea92fc453743265c8d54d9a24c3fafd0493f332877421723ae219093694918bd26205357e3adaf0baab6c1d45d5812e3715023853044192f72caa581342f6cbcd3dc1f727a8e1872f047b2a8476be02a2eb7f28f0789ec699ae411716d41b6ec705547248198dea195af36023b73f747def5cff4e4fa676f3cb460e3b44eb563c44ddca850f08930c87469fae24dd1b2d82dfc2e228cf8b831548fc022b86eb3bfb562ba1855e26d949b8bf2b9949081b62b8948e879f058c8dc69d7c8041efedc3f8c1230e0dac8a231642ce86c82aec7891834b1c2770428954649ae8c6f889ccb21631cdaea3b2dcacd9e56f58b1c28fd1d52e851eb8d1d14d8ca6af7c5262da503fd5ac78db844822809db1bd0449ee0b2e1e36277d0f52cec5676a3d103ddbbdf0fbdee12d4d67b0f59def158eba40298fd625d895dcd06101fc5f091fb23b821355833480e3c6cb746af750e791f58e880c7e3cf0843a4aed433512784201acdc90803d5e71043f444ed088e1b22c71bfbff163b3204510529a206a4bf918303ada3085d96ceb1751e535f391188ddc7af12dc5ccbdcfb7496929f58eb5006fae0580e8f878404ce127152579cb968d9544eef9d417579d0d7acab1539e77dcef855263ef68e0fd071c40224367017bf154b2177d70f17021d7ce7d53cfa30a0c4bab8f642ec3d92f5d1298a2c5e861f02b17625b89f0396ba40d7086075c0b77083b2a30d0559af960220d8e78b4772d69dc43704603c1fd8606d2d30b19308dc28ce3d8d4b506d71d3830e39bdc5efaea248971947b892c12689e0819290b07eb2571a1c8a9fab979af5a0474ba9fa61738f70a1ae0cf5f871ed7f0259b054e4ef377490ed8eed61ab2f1822ddcdd52771db1615aff825da0531f0c8e1ab3c0fb8696ebc964bcadc0c6df1b0704a3758862171cc5db896ee6b4aa64260c04ab5d29e676b93eacb0e27271afcbc505542d53baec6595fbec9aeb0929ab42c688ab525781f844beb9fdb817b9f1ed394bf5225377c33c5968aea5cb96316dbdefa716629ff70198a5a722857f3054f14ff1616ef360427aa9c346fa2432c40c33b440474f9ed68f2c314728f0d0fe439f274d9be86fbd2535cf3a6246aead4964fc5591ba67bf42b1b1a53823dce31e85c98b6f2cb4587bcdb7f38173d7e3744efc0a0350f25504ba8a84532e9be1e5385046519fef42ffdbfbcd36d35cde1d6b4bb456","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"372ee9a3e3557790ebe9e6f397938a2f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
