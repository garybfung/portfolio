<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>

                body {
                  background: #424242;
                }

                .staticrypt-hr {
                    margin: none;
                    border: 0;
                    background: #424242;
                }

                .staticrypt-page {
                    width: 100%;
                    max-width: 360px;
                    padding-bottom: 120px;
                    margin: auto;
                    box-sizing: border-box;
                    background: #424242;
                }

                .staticrypt-form {
                    position: relative;
                    z-index: 1;
                    background: #424242;
                    color: white;
                    max-width: none;
                    width: 100%;
                    margin: 0;
                    padding: 0;
                    text-align: center;
                }

                .staticrypt-form input[type="password"] {
                    outline: 0;
                    background: #5F5F5F;
                    color: #FEFEFE;
                    width: 100%;
                    border: solid 1px #424242;
                    margin: 0 0 12px;
                    padding: 15px;
                    box-sizing: border-box;
                    font-size: 16px;
                }

                .staticrypt-form input[type="password"]:focus {
                    border: solid 1px #787878;
                }

                ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
                  color: #BDBDBD;
                  opacity: 1; /* Firefox */
                }

                .staticrypt-form .staticrypt-decrypt-button {
                    outline: 0;
                    background: #292929;
                    width: 100%;
                    border: 0;
                    padding: 15px;
                    color: #ECECEC;
                    font-size: 16px;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    font-weight: 450;
                    cursor: pointer;
                }

                .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #252525;
                    color: #EBEBEB;
                }

                .staticrypt-html {
                    height: 100%;
                }

                .staticrypt-body {
                    height: 100%;
                    margin: 0;
                }

                .staticrypt-content {
                    display: flex;
                    justify-content: center;
                    height: 100%;
                    margin-bottom: 1em;
                    background: template_color_secondary;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }

                .staticrypt-instructions {
                    margin-top: -1em;
                    margin-bottom: 1em;
                }

                .staticrypt-title {
                    font-size: 1.7em;
                    font-family: 'Inter', 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, serif;
                    -webkit-font-smoothing: antialiased;
                    font-weight: 500;
                    letter-spacing: -0.02em;

                }

                p {
                  margin-bottom: 0;
                }

                label.staticrypt-remember {
                    display: none;
                    align-items: center;
                    margin-bottom: 1em;
                }

                .staticrypt-remember input[type=checkbox] {
                    transform: scale(1.5);
                    margin-right: 1em;
                    background: black;
                }

                .hidden {
                    display: none !important;
                }

                .staticrypt-spinner-container {
                    background: #fff;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .staticrypt-spinner {
                    display: none;
                    width: 2rem;
                    height: 2rem;
                    vertical-align: text-bottom;
                    border: 0.25em solid gray;
                    border-right-color: transparent;
                    border-radius: 50%;
                    -webkit-animation: spinner-border .75s linear infinite;
                    animation: spinner-border .75s linear infinite;
                    animation-duration: 0.75s;
                    animation-timing-function: linear;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                    animation-direction: normal;
                    animation-fill-mode: none;
                    animation-play-state: running;
                    animation-name: spinner-border;
                }

                @keyframes spinner-border {
                    100% {
                        transform: rotate(360deg);
                    }
                }
        </style>
    </head>

    <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
          <div class="staticrypt-form">
              <div class="staticrypt-instructions">
                  <p class="staticrypt-title">Site is protected</p>
                  <p></p>
              </div>

              <hr class="staticrypt-hr">

              <form id="staticrypt-form" action="#" method="post">
                  <input id="staticrypt-password"
                        class="staticrypt-password"
                         type="password"
                         name="password"
                         placeholder="Enter password"
                         autofocus/>

                  <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                      <input id="staticrypt-remember"
                             type="checkbox"
                             name="remember"
                             checked/>
                      Remember me
                  </label>

                  <input type="submit" class="staticrypt-decrypt-button" value="Enter"/>
              </form>
          </div>

      </div>
    </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator =
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"970917169d4e0740608977fcb4ffafee39c2b5848684a3ddb53cc087e3e890ac0da61909037144a394eeddf3a04a54de410ed83b9c8cde17c5c33bdfa15571629215a1ed3c441d363baf98ece6020afc282107f263a55bf6ea0af50d485d7657b27b0ebf3aa11e73f43f1812e988309b92899ad2df891a937a66e6a7a2ca170a5ed34864450fad1ea0a3be4ce20548c482a94e5c888a99675438d964f301f1e4cdde628e727291adb5b3b7efc80905a5d3ae603faf84680a1268e5256f9ffda7b19094a55c34ad86bb44898599d4b6dfc39ee171262be73f9b597652d434f2ca3a489ad1ecfab6425eb25952113569cdf5f2da56f3031e690f8c3cf9beb7419a1bb9559add2ac04d62a09b26cd6f233ce3e828cb157ef143c9f6117f6eacce709984a493e5e18b5f027713b86dfc1f15d239a0a4a76376b062cdd17f4d408c1462fbd8a15f5fecba7039ee21f078a1cab002e55ea7117ff0976d3b98d3c4881576c9bd5b4ae644e92e9090b036a91504d0f8f114e562bf7813681b6e375574b6cd0db5fa26efd4fb7d292d904481262461a0db4db4242d383641f556131a0957b38833497fa0bfde6964fa87a07ab4ac07f04b921a284c7252edf8476213e90b54fb940a2ae977db2041dc19e824141fe4eb5ff75f77e4d02af1389987f7c5cd0d1847f450ed070095dfd30ddaafc98a7c3db21ebac1528cea31615e5b83f6b6e4f6496343bf7c3c93b4dce72d3e703c0c852b1155d4d7540f937629b1b0bb5a2ed8d746205d73fc959b0fd289e95e7e07e3705d2c59c725cb181a52e9ae5932bad8ff1960d321dc31b1e75c3be6a26a8a74d9c57cac72686a1b4c7705d342fb707b875b210d45ebfe78dab353aa70fb55a958f1f0e1efc351661292c2bd4aa31eda07ed4ee51612aaea3dcd5396098d7242752e3c9d18bfdd376ae56c7e6be7dc626db93db1b4c96398162baeb572fa85fd74c1eae8ef6aea95206d6acf0b6e1ec876406b1b9bdfe7d6ecfe07456eb1c04655bf091b00af91f98a95901061aa57c6feabc53f11eae030c391d56cad17bfdc37f5721f86ed03667cdc675ecaf50a1b6fd1c5e07f7402c95c15eefe0915cad5bc898fc24b5b77a5222f6b0b24733a1eee2a8d416c3fada7ba48f502dfcd888ec17277f3c073f6b125109bc320f9b171d83924b4ac7a36788ae1fc4334882fe673aeedf6abf9e771ddaebdce86a7b0594737f8148eee37e61ee0a09a513345f775369bfc2bf0e5c3c28a844ef19ec305918377b6130e57ca16996023978fc089ca3ad1c74ca5c68b30bd70f936d080f1eb484528da6ce85f08a05eb46a2da19f9a1c177bb1788e20eda1cd3f5699898ac1405a9467347db08790489d3fe30b5d8419a1b72e5f5e8d61f048a9a700dc4a60557d17855810b506780ce04494b2c3c3ca6310a3b955db47eab7d6c4222a64c8aa2d2ceb2875c1718b1843a2cd88f2edf158708b5d92f205c50ff8532c0fcb82c6b5524f975019f0059aad77d6cd1d603a5352b605b2c8106d9a608ef921673582703e3edcf0cab3e57ef31f4d5117996dac73749c454a30a493d34a5b7043c238d4ce552f68c044c2c1d2dafaeb48e5f52b9b9a048a1176e04f712fb47068081b01a789a1b60119706f275213ac6dfbd0e7603ee260b599ea36c01e29caad65530d738aeb0e615f8be9f53ce0c23d2f6260726296563c1a3119c6a9d99eb42400361928426ee745aa01825745b29381ccb2945a9c9f1e64e839a8161badd483b49eb8ba8b661e89dcb0409acf1c270593216672e23c459d0bb3315b543e7eea614a33d012c8b441ad73f1259a14a3fab89dd68561bebd7b1e302ebf181868608265e1a0a69022f87bd7316fbac0f9c42fb0ca484fd59b447c64e0fa625d9ada76c904bbec9fccfdcc1f92dc0ac01293941aee1450b5ccc00871c9bd479313c0b414e4a3fc5f7ae83180fdff05bcdb553aad2405119de9880f993692ae93b99068048de883b6514c7e89bb80303bbef08fa8a159c6e7bf299bdfcf71a978a5ea2e5b10cad4ea01621343fd3c088b9510809d301868701e06300bad9d01319c96bf8d8e40ffda2291b06300ccbe878bd7bf116fd1d920c800682dfa4dfb660e60f0ab033a2c6557927c5ec2522144012cd950325084227df02e59003cd079e3a0471d272ed8feedfa9c0aa0adfae412e0649ea1034ec63926b940e14af8b4d3818c661263391cf30b870c58e3c690b9f0b5ce803499f250c3bb08ea3e4218a39750341e955ef126bcc7a1a082a69a0a71177c450833f4d074dbe88f9030713f608a7baa07145ca935708f261796a65d926575f81e621e56df00880b75e9660f9d2c0ad5d95d631ee25c54fe5a424d12d0c4778bafbcab7145ef0901d3fcce564b517d82a26e473a5114ef0de095f37a0799ad8eadf402def9fcd3f5dddca08e2405ccfbdf3bc1bffcd0140ebc64a4b9502e87acab7996b663cff03e6989347a0b866b98c2d42e913c4678f74ebb63b090079e1028f9c96873b070b31239dd620cf44fefa3b3fda223012c0c047502e23fe58337aaf7d9eac77dcbef7e64d866f92596b67f9191a38ca24189193bac5dc77f223a63a33b4beabd9193c983f386aed9f93458bfc5812dcfa1f70b74be323eaeeaa38bcf2e9b82032e3c228a47944e0f50a0eef2b9935b701d11cce459edbc68fbf1525f97ee7ee102bd0ec14460debf1980f72d01108b8d780c99dbf8f161889a687e2cc3bd21376bd1185630385b55ec5c722bf2958ae4d72411cf7c416b8f3fd188c821287e74701dc14c5d25f6690905820b5d1a0d52bd897a4a6c29f71f95dd018419a2cfc8f58d12db012ef5feb2fd8df16dbc46aa08ab94e68e8c15ca2900322280d1cd51823464c5de06ef96ab96ac230770716fb116f4043b10b58385293b2161588c5932987dd12a1e25bf09dbb8160c4777a51ad90acd2591c077c4dac0100ba231ab96815a787e4b36228dbe1fb550c10c31e39e6e22d20738d317b3d0584be6a9234ab311b4343d11e2808625f9bd6fb88cc79514c1c4b1dd40b21cd1147e9564884ddc4c22d8724f37ef675a54fd3d4bc227adbb1041c75c57fccdc5fa996f5f649af9542a348d6339f7185da429f13a06f9561bbe0dcca3e3034f8021158815d3e1ffe93ec5892e4bea91e0c1877051802df7367ea250830169e165c3cc280e8673f331d777432c14530ba0c3210d6df29c7548ea84e112ca0b70fc3da59990cccc0f652c26716cc555b5e943f21f1edd38ab79e9b395814e1ee0af4685a232abbf2da9d42d2e24fae90845d25267a3ab244657b82e31a56cc8eadf94b2c6215d23c1bdd887d59bb2b23b760eecf1205b90ed3e6a538459faea877e88bc427178d609689d37b30bf35800c6d32e403562fac70d2588b583aac89df3730dea0ee1b0ca2e1392ab281bafeefba9e42818a1fd2e6e343884da16d7888e3b379050e2f7e6f5b0603af853b3f3d6115a041ba1ae44bdaf165291999a7cff83c541d4839233d235f3387e58b1c4320a988b284f393e4788317392286366ccc44b5476c989dd2bc8d614ec250b80269b42a1ce87c158c74a70e02d2dbb66fc7db01a0c100914fd11080681e3c5bcbcea8fa4c4c8a4dd0034d8967d45fddb277cdd9aab03813221bb3e45b3d0a2b29a9e2d1d22864381642a1d37e110d9b9013b32db4cc1699aa50eef234e6452417b1eae247177add83405c989bbe78049c628cd180eb5ab59e0a8c3f001cf4e90676822f110a2302613dd3542793f7db384adeda6cb1367cd6bd738d5b2470b6928ca6e594465d12e56b050a051cf41c59280b605f44b7ce69b465e93fc89ec6861e1e5f89b56abed16b85183350f27849edb820b4442c4d8efbc397e1cb9d656cd9eacd81a2bedb69e4c7232d3ecbdc0b9afb511926082a53d79880a6c54687f3481f25ce790554ea221e2eb3cebcb266ec4a4fb85a03394533b350754f01120964b00ec5c4e1d387da93700b03933ffbbf8c86bb581bd69c335f984ab8f48432a106e3544a2dfce824583d8fd13dcf5eaa981fff04a27731f4690a2eae171cdc4429eea870ad04d685732668932d1c2b22ac07fdaed2e483095a8474ee3e08c194b0ca266dd5a26ef496c38fbfdd61476e94f1ff0e7411ab2208f6ed64d91544ae69550cd294a76c46ab9fdb9805aaf2b4f1905d9672a1cc5275f9ae9c3ce781c6b974a1fac556dc777001b80ff5f915981eb76f560f340bcf2d65d31360e059c4b4294200f7a1258297d7352f409345e05c9d71df8ff84a1aa237c2e991d5e1824b4430ac460d5f98bb9c78fc75c2914d6fd78ec026b13d29003faf3423758d4beb8ca06ca74ab25210eb156515eeed47bb9d7a39af6547a906721da66c220def102f76632a7cb55b1e20d3dcca6e14a5a6420cb558405968772f9ae5043bebdf2c3a32f2ce68c94502bd3aeaeefb1b192a0a7bcd138000fb2e772b90bfe65c5a569e9fcb83ab5eb8c07f62466206546cb3792e5b3fdf18a954dd62a1d68075e77e1610af5022748575cc2552195b22034673a947dd753ee5dcc0f9e883756f80cce13b33d5a13954247cc9a1be27d9502917738862a2710a87270a3ad579c3ba65a796f344d54ce783ea1eaa5ddc6a47d2b93a94d9cd5df858ab7b46448ab4eb282083297ed18b53f4549065421d5f75ce82dcbf911d91a9134f4499efb35c54c766c1d52f901f8928d634d504f51ba00ab4fac72dc28502d5199cbdad7df55022f9b6c2883e5305da998208c1395e553600e3fad68b5def3a3f74fc2899f36e602f2200dc29d73d08df993fa03f5e842715ec7938966bade55d36228198878cc2e113cf1a36f3f85a4acca395354fb2d112b41e1f6bdd57e4c809bcd7d075cfc7fa590808ccf07bd1775fe254464880d37a617cf05fb73e20478cb8bf866b50a201df5d6d0718c0da9064213ca313f9b702be82f260196d74bc8e8c4f66b140cd8be6465c186babcd97ebf001b9891b6c964b5f8ef0f21012dc7b69f0f16f8e4312337981a477d494263e125ff1570faea09e7a1d3c1189be17b44c83d09dd1aad1451d4c33515363d8cc35d21951812637cb7e44adcf391dc70cda37b1f0e60a8f967c8c9cd2d3eb50c820b1d03ac6b77b5ba44d758d483c017184d64aa32feb47cfb3159e41f932c6a11e18916b8cebe81b226e54afe3b93df45f983736aeb12c8d3b71eb81f7fd51acd0f64479e965be771a3a70859f63c9fbeb0c4b3b46181191f495da2e3f990eb9a3155da26c0e0e1e73706bf1f4d3df2dabd812c634d5c8a38d6a13a1650c47b995e00a053a2778b02334e0cf3d9110297ad41caf61a72f83ba32fa94c05f21225c472394ca54273f708a92f99b33c79433c2bc6afe5f3cdc74cb6e628e6a2e2eb4754e0cd7e6cdc1c46d2770511768b55a288eaa7ee2eb7b652ffcc84715f532a58f7ab444b23a3da106e6c0191b3dbc743911a5c36030b29d498294c1dfe3b2cfb0194a946b99191435198c05c93e04f24a804db9c857c46f092112a0ba147b31f45666df23a908c5a2271ec523547b090ac0c63d0478600d3ab37822de11868bab96b9dff0fc878c061bf2d87777d1c205d05f8135f5ec559957abf108ca29fa65ffd39cad781487b18e907e2f89132ef9933d9b54e1c48297e3f6a201c1f2972ee2b05becea47450389c0ba0671ae3362d96b07e483b96bce23171bc78e1f7f94d736908ddc954e1a7b44850aaffa643d914ac0584bb8187e048334776a8304f803d3d4fe79add226b4e0e00b652edbb02cef90400695a7056a9a78c820b73add108159601bd026ea1d1fe435f95342f426aa11fe4dc44bfc3b18c957f80acfec83ed4a342bc318e6153122fc23cbb0d188aafed284ef1531fd7836e255f29bfe9a65b5bb4dd1ae68f5361b0278e46ff8ad25fcfcd2ff8fa7b0601ef03d50c473cbce94a480fa7d8195d9096dce1475938b6a80232739ad4cc565b328a8ed82a19152fbd141c76738a76177c8d5af13da93fa7afe5c3a8ebf6999daf166690d69189ae2ad451f85abca9bdf2f02d1b2dac3c0234a459c7b54ca0c4b80c18dbef2153ece171e2b2fea8f11c26ecc647e2dd29b885909af9b7f7113b4083a21c3b289737988ccf159521592139aa7615d0feef855fcac2f5d23f3a65e10a2d382168bf891a71aef19cdfd47569fa4a46ecc905a87d20541d5c7e182f88adf709ff29ad0f297db27346e2318b853b38636276e6ffaf67322a7a8eb7f08a6154cf20c6eb117b0bd79fb6f33a8cc6d26e986b5995a6828a9f9d64c16a6119e996202a0b48daf22da9b84a16914089837bc16bb93f01dc9b24ac770e9f01b2b1b3e35e21ce757838ef422169af856002eb6ed5aa02a0cfe415c0d59ca0180176c1bfec53ff84fd8e0613ca8d9bb8b413cb906c4e263786d72bd02c1f213f9919b8d285731c9148ae61300c3c0aed2a9cbb9311ff1750ec3f5a8f6d4f2fbd960f61bf31f220ce5250e2c5c5d17205bfe599dc3510d3d44f718ccdb7bd19982fadab3430cbab97be1a387428d6e84d77c9924bf55e22f358ae625921bc8bc546aca289dee05b38fc3ef067c5f188194644c10d879796c76c31d7937202b9298cbeec9d0f73cd8438bed4141030536379a55aa8d4b103261d9bee984a04bd81e877208826eec137e00e538580ab4dbcb19521325d099ed0a87d97fbb9fdbe62014dca89ff1f3c6370701b8eb441ec790a6e9923f2bf917a6deb13f620921b621cf0f2436661a4252a5bf49826ba78329ec05a1fe68f5495d7524d2f32e9379be43defcb7d2c990cd201607af426e6bbeb05624022f9ad3f9719a99d888c9e347785a19330e4c24dda1c0602f3f85c273ec151a5ed9fd55815a809fddd551d816bc82030c1dcee920191c020fc646011640f472fca6ebd9b4a60236941b1646c347b4923fa1121a22a6f496df2c43c008ee405c3b9ae627eb5e3aa8866306373da8f936bb147067d05c7f90ab2ff594902b094323edb6d15b14b9d1bc012607640d0900d80939b2000ea64be0a77bc65b1e85110f413f9c5e82cbab07936862a0b51b4362d7c8f952ca8a3444d20ebc2e2eed0b61cb8498a5afa36556491a4f029487cdb9249c4170d33c5d5bbd2a4bcd3411aaebdac53993d076865e8abe2f6e4e7580dbb1a8f403be32925a67b2b9047ac6658e316e787ea45dd4166c9e222d79b557f184d83c1c820319a6ce130840cc4b1d35617a42104ada193bd61ed9298a3ca69a7cbeb7050d3fc8df0c478a8d8c28f150a97989f4bfd69777092ed70ee08690a04f338a30efa57689a366ec9d5d4d00e97e827d9e42b47673d5ff88d39250a4bced02ff9b8521e32fb14a17134a57ae5e2ae38917dba4c1bd9c4eccef2f798370ed3068746406027f177e30a9ef1b35bb1e80e63bf2603baeb820d07ab6202f71bdea64efdef978c689960436eaf6bd1ee9fd596cfa7701904f681439a025c4f8f4c61b41c874279ad99f15742cb072cf782e30102e7a4b4cd3dd301511e0c792acac8c93fd11e04dd1829aae9e298cad371d26079eb399e5ee1c3e54b5c8715a3cb7606409967a9e8d8e891d423080f2568b86fbad3a734076d40572c8ddba05eee72d0cfe17f9b94c4ba9f7c4d3644ae37f5a84e40f7e0a71821b6e423a7d26b5b973919b93c41e9cc9ab2283d8dc621c3381fe1efec6118e8579cc56d5c9b4d4b22ca5ddbf28f7b5f172edd71dc39444eab92e34affa9636b292607c8d465a479fe5dfd5dec900ea4987be3ad6e0c4a5b1744a3290a4189a566fa324c94b4b73e8dc52eb9b10e99c07ad9eb86ff5c05392c56869e583cd175fc3a4cb62af72de469545f449e1d244593dc35c71af9c79c53aa14ef211cd7b32fc033b97e62b8d10a0d99869c6e9eff25ae36dc085c3ac356f267be6d8a605f291dbe2880d1274ff2197de50606880b2a3ac7327b1ee3f0cd80ad72c08f9da07f442aedabd5201b806c30cfc14ce0080dbacbc3bf1145d266884df3ca63b988ba830980509bb09cfc916bb254f24b480a6b6bd11adae144dfc2017b97b2f2dfb0ae86240740dc837ac384b4d152ad74249bc3fef042344c78b587ce7bf8da41d323b4754e517257b7f5999efe1dbaab27588059f8c5c23666e54614cf0407a7bba0799bcfe107f1f0f07a0017d5716d59117cdae08bbe2b74644305dd6d011389c1552a22cc5084a63e90eec84fc20f6d2dc49b8f809d433d43aaa716b401560d5534ebc8684b9e5624e6fd32327f0797486c5ca96e69ccf31e144263005e76d5b5e6ea945dfef8694591d81e51a9eb3e759526a0540114cb7d46dab96be57459f02dbdc45e3c031a2a6b44179e7ffbe21f47d62d856aaa0325adf37359562d4eb97b30ec7bf37e33e7b09616aea0dec1949b5aeeab52d759164c8181386022bb1ee31bebcc3a840335266fbbc88f322eb914e021747eb5f521aec93d6c9929dcc728f5038a010bb492ba84b5e5fa0d4c9569e37fbeade3172b629a2288c93e7d9c2bef4d67e5d305a1b17efb0c3618686af20f8fda6fec13970a0fd59b2e5cf0ed0a985717fa26fc17e1b271921509eccda54f733386a3d246fc57e576ddbf65ac516a349c63adeabc2c3a8c49f68441192cbf74e2dac15eff111ceea228de9aacf365a05662e829cf9ef51bf31ea6690c5f3c8b629ad874dc06a2b0c9db1705af7cd4002e008a8c67565dae16f8e2c8fe71","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5742d19a747464f06c5bca02aa782a58"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
